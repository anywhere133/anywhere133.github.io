---
title: "자료구조 with Python : Part 6-3 2-3 트리"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 2-3 트리
  - data structure
use_math: true
---

### 탐색 트리


#### 2-3 트리<sup>2-3 Tree</sup>   
* 내부 노드의 차수가 2 또는 3인 균형 탐색트리이다.

2-3 트리는 이후에 공부할 B-트리의 일종이다.  
레드블랙트리는 이 2-3 트리에 기반하고 있다.

2-3 트리에서 2-3은  
차수가 2인 2-노드와 차수가 3인 3-노드을 뜻한다.  
여기서 2-노드는 자식노드를 나누는 1개의 기준, 즉 1개의 키를 가지며  
3-노드는 자식노드를 나누는 2개의 기준, 즉 2개의 키를 가진다.

그리고 임시적으로 3개의 키를 가지는 4-노드가 있을 수 있다.  
트리가 연산되는 동안 일시적으로 생성되는 노드이지만, 절대로 트리에 유지되어 저장되진 않는다.

2-3 트리의 높이는 트리의 모든 노드가 2-노드인 경우부터 3-노드인 경우까지 연속적이다.  
트리에서 모든 노드가 2-노드일 때, 트리의 높이는 $\log_2(N+1)$이다.  
왜냐하면 모든 노드가 2-노드인 트리는 포화이진트리이기 때문이다.

반면 트리의 모든 노드가 3-노드일 때 트리의 높이는 최소가 되며,  
이 때 트리의 높이는 $\log_3 N \approx \log_2 N$이다.


2-노드                      | 3-노드
:-------------------------:|:-------------------------:
![][2노드]                  |  ![][3노드]

##### 정의
* $T$가 키 $a$를 가진 2-노드이다. 만약 $T$의 왼쪽 자식 $p$과 오른쪽 자식 $q$이라고 하면
  * $a$와 $p$와 $q$의 관계는 다음과 같은 관계가 성립한다.
  * $p < a < q$
* $T$가 키 $a, b$를 가진 3-노드이다. 단, $a < b$이다.  
  만약 $T$의 왼쪽 자식 $p$와 중간 자식 $q$와 오른쪽 자식 $r$이라고 하면
  * $a$와 $p, q, r$의 관계는 다음과 같은 관계가 성립한다.
  * $p < a < q < b < r$

* 모든 내부 노드들은 2-노드이거나 3-노드이다.
* 모든 이파리 노드들은 같은 레벨에 존재한다.
* 모든 데이터는 정렬된 순서로 저장된다.

따라서 2-3 트리는 루트로부터 각 이파리 노드까지 경로의 길이가 같고,  
모든 이파리 노드들이 동일한 층에 있는 완전한 균형트리이다.  
그리고 2-3 트리가 2-노드들만으로 구성되어 있을 때는 포화이진트리와 동일한 형태를 갖는다.

##### 연산

###### 탐색 연산
탐색 연산은 이진탐색트리의 탐색과 비슷하다.  
정확하게는 이진탐색트리에서의 중위순회와 비슷하다.

**과정**
1. $T$가 2-3 트리이고, $d$가 찾고자 하는 데이터 값이라 하자.
    * 만약 $T$가 비어있으면, $d$는 $T$에 없다.
2. 그렇지 않다면, $t$를 2-3 트리 $T$의 루트노드라 하자.
3. $t$를 이파리 노드라 가정하면,
    * $d$가 $t$에 존재하지 않으면, $d$는 $T$에 존재하지 않는다.  
      반면에, $d$가 $t$에 존재하면 $t$를 반환한다.
4. $t$를 왼쪽 자식노드 $p$와 오른쪽 자식노드 $q$를 가진 2-노드이고,
   $a$를 $t$에 저장된 데이터 값이라고 하면, 세 가지 경우가 존재한다.
    * 만약 $d < a$이면, $p$를 $T$라고 하고, 2단계로 돌아간다.
    * 만약 $d$가 $a$와 같다면, $t$를 반환한다.
    * 만약 $d > a$이면, $q$를 $T$라고 하고, 2단계로 돌아간다.
5. $t$를 왼쪽 자식노드 $p$와 중간 자식노드 $q$, 오른쪽 자식노드 $r$를 가진 3-노드이고,  
   $a, b$를 $t$에 저장된 데이터 값($a < b$)이라고 하면, 네 가지 경우가 존재한다.
    * 만약 $d < a$이면, $p$를 $T$라고 하고, 2단계로 돌아간다.
    * 만약 $d$가 $a$와 같다면, $t$를 반환한다.
    * 만약 $a < d < b$이면, $q$를 $T$라고 하고, 2단계로 돌아간다.
    * 만약 $d$가 $b$와 같다면, $t$를 반환한다.
    * 만약 $d > b$이면, $r$을 $T$라고 하고, 2단계로 돌아간다.

2-노드는 이진트리의 중위순회와 동일하다.  
그러나 $a, b$를 가진 3-노드에서는 먼저 노드의 왼쪽 서브트리에 있는 모든 노드들을 방문한 후에 $a$를 방문하고,  
이후에 중간 서브트리에 있는 모든 노드들을 방문한다. 다음 $b$를 방문하고,  
오른쪽 서브트리에 있는 모든 노드들을 방문한다.  
따라서 2-3 트리에서 중위순회를 수행하면 키값들이 정렬된 결과를 얻는다.

###### 삽입 연산
2-3 트리에서 삽입은 균형 이진탐색트리의 속성을 따른다.  
그리고 삽입 연산은 세 가지 경우로 나누어진다.

1. 2-노드에 삽입
2. 부모노드 2-노드를 가진 3-노드에 삽입
3. 부모노드 3-노드를 가진 3-노드에 삽입

![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/2-3_insertion.svg/581px-2-3_insertion.svg.png)

삽입되는 위치의 노드를 $N$이라 하고, 그 노드의 부모노드를 $P$라 하자.  
만약 $N$이 2-노드면 $N_2$이고, $N$이 3-노드면 $N_3$이다. (부모노드도 동일)
* $N_2$에 삽입
    * $N_2$의 키 값 $a$와 삽입된 값 $b$을 비교하여  
      크기 순서대로 $a, b$를 정렬하여 저장한다.

* 부모노드 $P_2$를 가진 $N_3$에 삽입
    * $N_3$ 노드에 키가 삽입되면, 임시적으로 $N_4$ 노드가 생성된다.
    * 임시 $N_4$ 노드에서 키를 크기 순서대로 $a, b, c$로 정렬하여 저장한다.

    * $N_4$ 노드가 $P_2$ 노드의 왼쪽 자식노드라면, 중간값 $b$를 $P_2$의 키 값 $p$ 왼쪽에 저장한다. (승격)
    * $N_4$ 노드가 $P_2$ 노드의 오른쪽 자식노드라면, 중간값 $b$를 $P_2$의 키 값 $p$ 오른쪽에 저장한다. (승격)

    * 승격한 $b$ 값으로 인해 $N_3$가 되고, 이 노드를 다시 분리하여 2-노드 2개로 만든다.
    * $a$ 값을 지닌 $N_2^a$와 $c$ 값을 지닌 $N_2^c$ 노드를 생성 (분리)

    * 키가 삽입된 노드 $N$이 $P$의 왼쪽 자식인 경우,  
      $N_2^a$를 $P_3$의 왼쪽 자식노드로 지정, $N_2^c$를 $P_3$의 중간 자식노드로 지정한다.
    * 키가 삽입된 노드 $N$이 $P$의 오른쪽 자식인 경우,  
      $N_2^a$를 $P_3$의 중간 자식노드로 지정, $N_2^c$를 $P_3$의 오른쪽 자식노드로 지정한다.

* 부모노드 $P_3$를 가진 $N_3$에 삽입
    * $N_3$ 노드에 키가 삽입되면, 임시적으로 $N_4$ 노드가 생성된다.
    * 임시 $N_4$ 노드에서 키를 크기 순서대로 $a, b, c$로 정렬하여 저장한다.

    * $N_4$ 노드가 $P_3$ 노드의 왼쪽 자식노드라면,  
      중간값 $b$를 $P_3$의 키 값의 제일 왼쪽에 저장한다. (승격)
    * $N_4$ 노드가 $P_3$ 노드의 중간 자식노드라면,  
      중간값 $b$를 $P_3$의 키 값의 중간에 저장한다.
    * $N_4$ 노드가 $P_3$ 노드의 오른쪽 자식노드라면,  
      중간값 $b$를 $P_3$의 키 값의 제일 오른쪽에 저장한다. (승격)

    * 승격한 $b$ 값으로 인해 $N_3$가 되고, 이 노드를 다시 분리하여 2-노드 2개로 만든다.
    * $a$ 값을 지닌 $N_2^a$와 $c$ 값을 지닌 $N_2^c$ 노드를 생성 (분리)
    * 승격된 $b$ 값으로 인해 $P_4$가 됨. 3-노드로 만들기 위해, $P_4$의 중간값을 승격시킨다.  
      이후 남은 두 키값을 분리하여 각각 승격된 키값 노드 $P_2^{부모}$의 왼쪽$P_2^{L}$, 오른쪽$P_2^{R}$ 자식노드로 지정

    * 만약 삽입된 노드 $N$이 $P$의 왼쪽 자식노드였다면,  
      $P_2^L$의 왼쪽 자식노드로 $N_2^a$로 지정하고, 오른쪽 자식노드로 $N_2^c$를 지정한다.
    * 만약 삽입된 노드 $N$이 $P$의 중간 자식노드였다면,  
      $P_2^L$의 오른쪽 자식노드로 $N_2^a$로 지정하고, $P_2^R$의 왼쪽 자식노드로 $N_2^c$를 지정한다.
    * 만약 삽입된 노드 $N$이 $P$의 오른쪽 자식노드였다면,  
      $P_2^R$의 왼쪽 자식노드로 $N_2^a$로 지정하고, 오른쪽 자식노드로 $N_2^c$를 지정한다.

위의 과정을 그림으로 표현하면 다음과 같다.
![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/2-3_insertion.svg/581px-2-3_insertion.svg.png)



[2노드]: https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/2-3-4_tree_2-node.svg/166px-2-3-4_tree_2-node.svg.png
[3노드]: https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/2-3-4-tree_3-node.svg/180px-2-3-4-tree_3-node.svg.png
