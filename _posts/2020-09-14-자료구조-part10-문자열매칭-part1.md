---
title: "자료구조 with Python : Part 10 - 문자열 매칭 Part.1"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 문자열 매칭
  - 원시적 매칭
  - 오토마타
  - 오토마타 매칭
  - data structure
use_math: true
---

### 문자열 매칭

#### 원시적 매칭 방법

문자열 매칭은 텍스트 문자열 $A[1 \cdots n]$이 패턴 문자열 $P[1 \cdots m]$을 포함하고 있는지 알아보는 것이다.  
$P[]$는 $A[]$에 비해 현저히 짧다고 가정한다($m << n$).  
여기서 소개하는 원시적인 알고리즘은 초등학생 정도면 쉽게 생각할 수 있는 매칭 알고리즘이다.

$A[1 \cdots n]$이 패턴 $P[1 \cdots m]$을 포함하고 있는지 알아보기 위해  
먼저 패턴과 $A[1 \cdots m]$이 일치하는지 보고, 다음으로 패턴과 $A[2 \cdots m+1]$,  
다음으로 패턴과 $A[3 \cdots m+2]$, $\cdots$ 이런 식으로 계속 비교해나간다.  
패턴을 총 $n-m+1$번 비교하면 작업이 완료된다.

위의 알고리즘을 구현한 코드는 다음과 같다.
```python
def naivematching(target: str, origin: str):
    target_length = len(target)
    ori_length = len(origin)

    for i in range(ori_length - target_length + 1):
        if target == origin[i:i+target_length+1]:
            return i, i+target_length+1
        else:
            return False
```

이 알고리즘은 말 그대로 원시적이기 때문에 개선해야 할 부분이 많다.  
예를 들어, $P = "abcdabcwz"$라고 하고, $A = "\cdots abcdabcd \cdots"$이라고 하면,  
$P[0:7] = "abcdabc"$까지는 일치하지만, $P[8] = "w"$부터 일치하지 않는다.  

위의 알고리즘은 어떻게 불일치가 일어났는지 상관하지 않는다.  
무조건 일치하지 않으면 한 칸씩 옮겨가며 일치하는지 비교한다.  
이 부분을 개선할 수 있다.

$A[]$에서 불일치가 일어난 부분의 바로 앞 문자열 $P[4:7] = "abc"$는 $P[0:3]$과 일치한다.  
그리고 $P[4:7]$과 $P[0:3]$가 일치한다. 그 이외에 $P[4:7]$과 일치하는 문자열은 존재하지 않는다.  
이 정보를 미리 알고 있다면, 몇 단계의 비교를 생략할 수 있다.

이 경우 불일치가 일어난 곳의 문자 $"d"$와 앞서 존재하는 $P[0:3]$의 다음 문자열 $P[3]$을 바로 비교하는 것이다.  
일반화하면, $P[0:m]$과 $A[i:i+m+1]$이 일치하지 않더라도  
$P[0:m]$의 앞부분과 $A[i:i+m+1]$의 뒷부분이 부분적으로 일치할 수 있다.

위의 알고리즘은 이러한 정보를 전혀 고려하지 않고 $P$가 모두 일치하지 않는 한 통째로 비교를 진행한다.  
이 이후에 소개하는 오토마타를 이용하는 매칭과 KMP 알고리즘은  
패턴 문자열 앞부분과 텍스트 부분 문자열 뒷부분의 일치 여부를 활용할 수 있도록 전처리 과정에서 준비를 한다.

#### 오토마타를 이용한 매칭

오토마타는 여러 개의 상태로 표현되는데,  
문제 해결 절차를 상태 간의 전이로 나타난 것이다.  
여기서 상태는 문제 해결 과정의 문맥을 반영한다.  
오토마타는 다음의 다섯 가지 구성 요소로 이루어진다.  

($Q, q_0, F, \sum, \delta$)
* $Q$ : 상태들의 집합
* $q_0$ : 오토마타의 작동이 시작되는 상태
* $F$ : 목표 상태(목적이 달성된 상태)들의 집합
* $\sum$ : 입력 가능한 문자 집합
* $\delta$ : 상태 전이 함수

오토마타를 사용하는 매칭의 예를 하나 들어보자  
집합 ${a, b, c, d, \cdots, z}$의 원소로만 구성된 문서에서  
문자열 $"ababaca"$를 찾으려 한다. 이때 다음과 같은 오토마타를 구성할 수 있다.

$$ Q = {0, 1, 2, 3, 4, 5, 6, 7}, q_0 = 0, F = {7}, \sum = {a, b, c, d, \cdots, z} $$

상태 전이 함수는 문자열을 찾는 오토마타, 그래프에서의 간선들이 나타내고 있다.  
예를 들어, 패턴 $"nano"$를 찾는 오토마타가 다음과 같다면,  
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F992BB1465B2643670B0C5A)  
상태 전이 함수 $\delta(특정 상태, 간선) = 상태$로 볼 수 있다.  
즉, 특정 상태에서 간선을 입력으로 받으면, 상태로 이동함을 의미한다.  

오토마타는 그래프로 표현될 수 있기 때문에,  
파이썬에서는 상태 전이 함수 $\delta$는 다음과 같이 테이블로 정의될 수 있다.  
```python
delta = [{'a':1, 'b':0, 'c':0, 'd':0, 'e':0, ..., 'z':0},
         {'a':1, 'b':2, 'c':0, 'd':0, 'e':0, ..., 'z':0},
         {'a':3, 'b':0, 'c':0, 'd':0, 'e':0, ..., 'z':0},
         {'a':1, 'b':4, 'c':0, 'd':0, 'e':0, ..., 'z':0},
         {'a':5, 'b':0, 'c':0, 'd':0, 'e':0, ..., 'z':0},
         {'a':1, 'b':4, 'c':6, 'd':0, 'e':0, ..., 'z':0},
         {'a':7, 'b':0, 'c':0, 'd':0, 'e':0, ..., 'z':0},
         {'a':1, 'b':2, 'c':0, 'd':0, 'e':0, ..., 'z':0}]
```
위의 리스트로 구성된 행렬은  
상태 0("")에서 간선(입력)이 "a"일 때, 1번 상태("a")로 이동하게 만든다.  
즉 `delta[0][0] = 1`은 $\delta(0, a) = 1$과 같다.  
"ababaca"의 오토마타는 상태 0("")부터 상태 7("ababaca")까지 여덟 개의 상태로 구성되고,  
시작 상태는 0, 목표 상태는 7이 된다.  
오토마타에서 시작 상태는 항상 하나이지만 목표 상태는 여러 가지가 가능하다.

오토마타가 주어졌을 때 매칭을 체크하는 알고리즘은 다음과 같다.
```python
def FA_Matcher(A : str, delta):
    q = 0
    F = len(delta)
    for i, s in enumerate(A):
        q = delta[q, s]
        if q == F:
            return i-F+1
```

알고리즘의 수행시간을 보면,  
for 루프를 단순히 $n$번 반복하는 것이다.  
반복할 때마다의 수행 시간은 $\Theta (1)$이다,  
따라서 알고리즘 전체에서의 수행시간은 $\Theta (n)$이다.  
문자열 $A$의 처음부터 끝까지 한 번 훝으면서 상태를 옮겨다닌 것이 전부이다.  

알고리즘의 수행시간은 $\Theta (n)$시간이지만,  
상태 전이 함수를 만드는 시간은 별개이다.  
문자열 집합 $\sum$의 크기가 $| \sum |$이라 할 때,  
상태 전이 함수 테이블을 가장 효율적으로 만들면 $\Theta (| \sum | m)$의 시간이 필요하다.  
상태 전이 함수 테이블이 행렬 모양이고 행렬의 원소 수가 $|\sum|m$개 이기 때문이다.

따라서 오토마타를 이용하는 매칭 알고리즘의 총 수행시간은 $\Theta (n + |\sum|m)$이 된다.  

이를 개선하기 위해 테이블을 만들 때 매칭에 사용하는 패턴 $P[1 \cdots m]$에 포함된  
문자들의 집합 $\sum '$만으로 테이블을 만들고 나머지 문자들을 하나로 처리할 수 있다.  
이 테이블을 이용할 때는 인덱스 변환 테이블 $i[]$를 사용한다.  
인덱스 변환 테이블은 입력가능한 문자들의 집합 $\sum$만큼의 크기로,  
해당되는 문자에 대한 상태 전이 함수 테이블에서의 인덱스를 저장하고 있게 된다.  
즉, 상태 $s$에서 문자 $r$을 만나는 경우,  
상태 전이 함수 계산을 할 때는 $\delta(s, r)$ 대신 $\delta (s, i[r])$을 사용한다.

이러한 방식으로 상태 전이 함수를 만드는 데에 걸리는 시간은  
$\Theta (|\sum '|m + |\sum|)$의 시간이 소요된다.
