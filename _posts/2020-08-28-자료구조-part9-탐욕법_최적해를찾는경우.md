---
title: "자료구조 with Python : Part 9-2 탐욕 알고리즘 : 최적해를 보장받는 경우"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 탐욕 알고리즘
  - 탐욕법
  - Greedy Algorithm
  - 회의실 배정 문제
  - 매트로이드
  - Matroid
  - Graphic Matroid
  - data structure
use_math: true
---

### 탐욕 알고리즘<sup>Greedy Algorithm</sup>

#### 최적해를 보장되는 예

##### 최소신장트리

이전에 배운 최소신장트리를 위한 프림 알고리즘, 크루스칼 알고리즘은  
탐욕 알고리즘으로 최적해가 보장되는 예들이다.

두 알고리즘 모두 주어진 시작 정점으로부터 이어진 모든 간선들 중에서  
가장 가중치가 작은 간선을 선택해나가면서 최소신장트리를 만들어 나간다.

항상 어느 시점에서든 가장 가중치가 작은 간선을 선택하기 때문에, 탐욕적인 방법을 택하고 있다.  
그럼에도 불구하고 최소신장트리에서 탐욕 알고리즘은 최적해를 보장한다.


##### 회의실 배정 문제

회사 회의실 1개에 대한 여러 부서의 회의 스케쥴링을 짜는 프로그램을 만들려 한다.  
사용 신청하는 부서는 시작시간과 종료시간을 적어 신청서를 제출하게 된다.  
이렇게 받은 $n$개의 회의 신청에 대해 회의실 사용 스케줄을 정하려 한다.

이를 위한 최적의 프로그램을 만들기 위해서는  
프로그램이 겹치는 회의가 없게 하면서 가장 많은 수의 회의를 소화할 수 있도록 하는 것이다.  
편의를 위해 회의실 사용 시간은 1시간으로 하자.

이를 위한 파이썬 코드는 다음과 같다.
```python
def Greedy_Schedule(S):
    # S = [(S_i, T_i) | i = 1, 2, ..., n], n = 회의 수
    # S_i : 시작 시간, T_i : 종료 시간
    meeting_count = 0
    time_table = []
    start_time = 0

    # 먼저 시작시간을 오름차순 정렬 후, 종료시간을 오름차순으로 정렬
    for i in range(2):
        S = sorted(S, key= lambda time: time[i])

    for time in S:
        if time[0] >= start_time:
            start_time = time[1]
            time_table.append(time)
            meeting_count += 1

    return meeting_count, time_table
```

만약 회의 시작시간과 종료시간이 동일할 수 있다면,  
신청받은 신청 목록들의 정렬이 중요해진다.

제일 우선으로 중시되는 것은 종료시간을 오름차순으로 정렬하는 것이다.  
그렇지만 시작시간과 종료시간이 동일한 경우를 허용한다면  
시작시간을 기준으로 먼저 정렬하고 마지막으로 종료시간을 기준으로 정렬해야 한다.

그렇지 않고 정렬한다면,  
시작시간과 종료시간이 동일한 경우의 회의가  
동일하게 끝나지만 더 일찍 시작하는 회의보다 앞서 목록에 포함되어 더 많은 수의 회의가 포함되지 않을 수 있다.

예를 들어 `S = [(2, 2), (1, 2), ...]`의 경우가 있을 수 있다.

이렇게 정렬을 한 뒤에 저장된 종료시간을 다음 시작시간으로 하여  
다음 신청 시간을 비교해나가면 제일 많은 회의 신청을 받을 수 있다.  
이 방식은 최적해를 보장할 수 있다.

##### 매트로이드<sup>Matroid</sup>

매트로이드는 독립성이라는 성질을 만족하는 수학적 공간이다.  
정확한 정의는 다음과 같다.
```
어떤 유한 집합 $S$의 부분 집합들의 집합인 $I$(즉, $I\subseteq 2^S)가 다음의 성질을 만족하면,
매트로이드라 한다.
1. $A \in I$이고 $B \subseteq A$이면, $B \in I$이다.  $\rightarrow$ 상속성$^{Heredity}$
2. $A$, $B \in I$이고 $|A| < |B|$이면, $A \cup {x} \in I$인 $x \in B-A$가 존재한다. $\rightarrow$ 증강성$^{Augmentation}$
```

성질 1에서 공집합은 모든 집합의 부분 집합이므로 $\0 \in I$란 의미도 포함된다.  
성질 2는 증강성보다 교환성<sup>Exchange</sup>으로 더 많이 부른다.  
더 명확하게 설명하기 위해서 성질 2는 다음과 같이 설명되기도 한다.
```
$A$, $B \in I$이고, $A$의 임의의 원소 $e$에 대해
$(A-{e} \cup {f}) \in I$가 되는 $B$의 원소 $f$가 존재한다.
```

위의 정의를 풀어쓰면 다음과 같다.  
집합 $I$는 부분 집합들을 원소로 가지는 집합인데,  
이들에게 요구되는 이 두 가지 성질을 독립성이라고 한다.
1. 집합 $A$가 $I$에 속하면, $A$의 모든 부분 집합도 $I$에 속한다.
2. 크기가 다른 두 집합 $A, B(|A| < |B|)$가 $I$에 속하면,  
   $B$의 원소이면서 $A$의 원소가 아닌 것 중에 $A$에 더해서 $I$에 속하게 하는 원소가 존재한다.

이러한 성질을 가지는 부분 집합들을 모아 놓은 집합 $I$를 매트로이드라 한다.  
이러한 매트로이드는 벡터 공간, 그래프 등에서 표현될 수 있다.

지금은 간단히 그래프를 통해 매트로이드를 알아보자.  
우선 그래프 $G = (V, E)$에서 모든 숲의 집합은 매트로이드가 된다.

그래프의 부분 그래프 중 사이클을 갖지 않는 연결 그래프를 트리라고 한다.  
트리가 하나 이상 모이면 숲이라 한다. 따라서 정점 하나부터 사이클이 없는 연결 그래프까지 숲이라 볼 수 있다.  
다시 정점을 제외하고 간선으로만 표현한다면, 사이클을 이루지 않는 간선들의 집합이라고 말할 수 있다.  
여기서 공집합은 모든 집합의 부분 집합이므로, 간선이 없는 정점도 포함이 된다.

$G = (V, E)$에서 모든 가능한 숲의 집합을 $F$라 하면, $F \subseteq 2^E$이다.  
임의의 숲은 간선을 최대 $|E| - 1$개까지 가질 수 있고 이 경우 단 하나의 트리로 구성된다.  
$F$는 매트로이드가 된다.

다시 종합하면,  
그래프 $G = (V, E)$의 숲 집합 $F \subseteq 2^E$은 매트로이드이다.  
그래프에 맞추어 매트로이드 정의를 이야기하면,  
- 어떤 숲의 부분 집합도 당연히 숲이다 (상속성)
- $|A| < |B|$인 두 숲 $A, B$를 생각하자.  
  $A$는 적어도 2개 이상의 분리된 트리로 구성된다. $A$에 속하는 임의의 트리 하나를 T라 하자.  
  $T$의 정점들에 대해 이들을 연결하는 간선 수는 $B$가 $A$보다 많을 수 없다. (많으면 사이클 발생)  
  $A$의 다른 트리에서도 마찬가지이다.  
  $B$가 $A$보다 간선 수가 많으므로 $B$에는 $A$의 서로 다른 트리를 연결하는 간선이 적어도 하나 이상 존재하게 된다.  
  이 간선 중 하나를 $A$에 더하면 사이클을 만들지 않아 역시 숲이 된다. (증강성)


그래프에서 숲을 키워나가는 것을 매트로이드에서는 확장이라고 한다.  
정확한 정의는 다음과 같다.

```
매트로이드 $I \subseteq 2^S$와 $A \in I$에서 $A$에 속하지 않는 어떤 원소
$x \in S$에 대하여 $A \cup {x} \in I$이면 $x$가 $A$를 확장한다고 한다.
$A$가 더 이상 확장되지 않으면 $A$를 포화 집합%^{Maximal Set}$이라 한다.
```

예를 들어, 그래프에서 최소신장트리를 만들어 나갈 때  
숲에 가중치가 제일 낮은 간선을 포함시켜나가면서 숲을 키워나간다.  
간단히 이 간선을 포함시키는 것이 매트로이드에서의 확장이라고 보면 된다.

확장 과정에서 확장으로 인해 사이클이 발생하게 되면,  
확장할 수 없게 되어 확장 과정은 종료되며 이러한 것을 포화 집합이라 부르게 된다.  
따라서 숲에서 포화 집합은 모두 $|E| - 1$개의 간선을 가지게 될 것이다.  
(최소간선트리의 간선 수는 $E - 1$개)

위의 포화 집합에 대한 설명을 일반화한 것이 다음 정의이다.
```
임의의 매트로이드 $I \subseteq 2^S$의 포화 집합은 모두 같은 크기를 가진다.
```

두 포화 집합 $A, B$가 서로 다른 크기를 가졌다고 가정하자.   
일반성을 잃지 않고 $|A| < |B|$라고 하고,  
증강성에 따라 $A \cup {x} \in I$인 $x$가 $B-A$에 존재하여,  
$A$가 확장한다. $A$가 포화 집합이라는 가정에 모순되므로,  
크기가 다른 포화 집합은 존재하지 않는다.


매트로이드 $I$의 원집합 $S$의 원소들이 가중치를 가지면  
이를 가중치 매트로이드<sup>Weighted Matroid</sup>라 한다.  
이 모델에서는 최적화 문제를 만들 수 있는데,  
소속된 원소들의 가중치 합을 최대로 하는 부분 집합 $A \in I$를 찾는 문제다.

그래프 매트로이드라면 간선들이 가중치를 갖게 되고  
간선 가중치의 합을 최대로 하는 숲을 찾는 문제가 된다.  
(즉 최대신장트리를 찾는 문제가 된다.)

매트로이드에서 가중치 최적화 문제는 항상 최적해를 찾을 수 있다.  
즉, 그리디 알고리즘으로 풀려는 문제가 매트로이드 구조를 가지면 최적해를 보장하게 된다.  
단, 가중치는 모두 양인 경우로 제한된다.

다음 코드는 최대 가중치 합을 구하는 그리디 알고리즘 파이썬 코드이다.
```python
def MaxSpanning(g):
    d = {}
    tree = []
    pq = AdaptableHeapPriorityQueue()
    pqlocator = {}

    for v in g.vertices():
        if len(d) == 0:
            d[v] = 0
        else:
            d[v] = float('inf')
        pqlocator[v] = pq.add(d[v], (v, None))

    while not pq.is_empty():
        key, value = pq.remove_max()
        u, edge = value
        del pqlocator[u]
        if edge is not None:
            tree.append(edge)
        for link in g.incident_edges(u):
            v = link.opposite(u)
            if v in pqlocator:
                wgt = link.element()
                if wgt > d[v]:
                    d[v] = wgt
                    pq.update(pqlocator[v], d[v], (v, link))
    return tree
```

위의 코드는 프림 알고리즘을 단순히 최소값을 저장하는 것이 아니라  
최대값을 비교하고 저장하는 것으로 바꾼 것뿐이다.

###### 문제 공간 탐색 관점에서 본 매트로이드

위와 같은 알고리즘에서 부분 집합 $A$는 아무것도 없는 상태에서 시작하여  
원소를 하나씩 더해나간다. 즉, 불완전한 상태에서 온전한 해로 변해나간다.  
마지막에 단 하나의 온전한 해를 만나는 순간 알고리즘은 끝난다.  
이렇게 쌓아나가는 유형의 알고리즘을 구축형<sup>Constructive</sup> 알고리즘이라 한다.  

반면, 알고리즘 중에는 초기에 임의의 온전한 해부터 시작해서 내용을 조금씩 바꾸어나가면서  
다른 해로 이동하는 유형도 있다. 이런 알고리즘을 개선형<sup>Improvement</sup> 알고리즘이라 한다.  

즉, 구축형 알고리즘은 만들어가는 것이고,  
개선형 알고리즘은 만들어져 있는 해들 사이를 돌아다니는 것이다.

포화 집합의 크기가 $n$인 매트로이드에서 하나의 해 $A = {a_1, a_2, \cdots, a_n} \in I$는  
$n$차원 벡터로 표현할 수 있다. 즉, $<a_1, a_2, \cdots, a_n>$으로 볼 수 있다.  

구축형 알고리즘이 해를 만들어가는 과정은 처음에 공집합으로 시작해서 최종적으로 $n$개의 원소로 채우게 되는데,  
원소를 하나씩 더할 때마다 중간해의 차원은 하나씩 낮아져간다.  
처음의 공집합 상태는 모든 가능한 해를 포함한다. 즉, $n$차원 전체를 포함한다.  
원소가 하나 결정되면 벡터의 첫 번째 차원 값은 고정되었으므로 나머지 $n-1$차원 값만 비어있다.  
즉, $n-1$차원이 된다. 이렇게 값이 하나씩 더해질 때마다 남은 차원은 하나씩 감소한다.  
최종적으로 마지막 원소가 채워지면 하나의 점이되고, 남은 차원은 없다.

이 과정에서 거쳐가는 중간 공간들을 수학적 용어로는 초평면<sup>Hyperplan</sup>이라 한다.  
구축형 알고리즘에서 값이 다 결정되지 않은 상태의 해는 다차원 공간인 초평면과 대응된다.  
매트로이드의 구축형 알고리즘의 진행 과정에서 거쳐하는 초평면은 항상 최적해를 포함하는 방식으로 공간을 좁혀나간다.

반면, 개선형 알고리즘은 온전한 해부터 시작하므로 하나의 점에서 시작한다.  
결정되지 않은 차원이 없다. 탐색을 싲닥하는 해로 주어지는 초기해는 거의 100% 최적해가 아니다.  
매트로이드를 위한 구축형 알고리즘이 최적해를 벗어나지 않도록 공간을 좁혀나가는데 반해,  
개선형 알고리즘은 탐색을 시작하는 해가 이미 최적해를 벗어나 있다.  
이 상태에서 최적해로 이동을 하고자 하는 것이다.  
해의 내용을 바꾸어 다른 해를 탐색한다는 것은 공간의 한 점에서 다른 점으로 이동한다는 것이다.

구축형 알고리즘을 통해서 최적해가 보장됨을 알고 있지만,  
개선형 알고리즘을 통해서 매트로이드 공간의 최적해를 항상 보장할 수 있을까?  
즉, 포화 집합인 임의의 초기해 $X \in I$가 하나 주어지면  
이를 개선해 나가면서 최적해를 반드시 찾을 수 있을까 하는 것이다.  
결론은 매트로이드 구조를 가진 문제에서는 개선형 알고리즘으르도 최적해를 보장할 수 있다는 것이다.

개선형 알고리즘의 슈도 코드는 다음과 같다.
```
Greedy2(I, A, w[])
-> I:매트로이드, A in I, w[]:가중치 배열

    while (w(a) < w(x) and A + {x} - {a} in I인 a in A, x in S-A가 존재):
        A <- A + {x} - {a}

    return A
```

개선형 알고리즘에서의 해는 모두 포화 집합이다.  
이 포화 집합 사이에서 최적해를 찾기 위해서는 어떤 연산이 필요하다.  
이 연산을 위해 앞서 이야기했던 증강성 혹은 교환성을 통해 연산을 할 수 있다.  

`$A, B \in I$에 대해 어떠한 $b \in B - A$이든 $A \cub {b} - {a} \in I$가 되는  
$a \in A-B$가 존재한다.`

따라서 $A$의 원소 하나를 제거하고 다른 것을 바꾸어 넣는 작업을  
여기서 진행하는 공간 이동의 기본 연산자로 삼는다.

```
임의의 해 $A, B \in I$에 대해 $B=A \cub {b} - {a}, a \in A, b \in B-A$이면,
$B$는 $A$에 인접하다고 한다.
```

즉, 한 원소의 교환으로 서로 이동 가능한 두 해를 인접 관계에 있다고 정의한다.  
위의 슈도 코드에서의 while 문이 인접하면서 품질이 좋은 해가 있는지 확인하는 것이다.

```
임의의 해 $A \in I$에 대해 $A$와 품질이 동일한 해들의 인접 관계의 체인을 따라
이를 수 있는 모든 해에서 품질이 더 좋은 인접해가 없으면 $A$는 지역 최적해 또는 끌개라고 한다.
```

임의의 해 $A \in I$가 봉우리를 형성하면(모든 해 집합 중에서 가장 최대값), 이를 지역 최적해라 한다.  
인접한 해 중에 $A$보다 품질이 좋은 해는 없지만 품질이 동일한 해가 있다면 $A$가 지역 최적해가 아닐 수 있다.  
품질이 동일한 해들의 인접 관계를 따라가다 보면 더 좋은 해를 만날 수 있기 때문이다.  
인접 관계의 체인을 따라 형성되는 품질이 동일한 해들에 인접한 해 중에 더 좋은 해가 없으면,  
이들은 하나의 지역 최적해 봉우리를 이룬다.  

지역 최적해는 국소 지역에서 봉우리에 해당하는 것으로  
봉우리는 단 하나의 해로 이루어질 수도 있고, 품질이 같은 여러 해로 이루어질 수 있다.  
지역 최적해를 형성하는 봉우리가 여럿 있으면 이중 가장 품질이 좋은 봉우리가  
문제 공간 전체에서 가장 좋은 해, 즉 최적해(전역 최적해<sup>Global Optimum</sup>)가 된다.  

임의의 최적화 문제에서 문제 공간의 모양은 이런 식으로 인접 관계의 정의에 따라 모양이 결정된다.  

```
매트로이드 $I$에서 $A \in I$보다 품질이 좋은 해가 존재한다면,
$A$와 인접한 해 중에서 $A$보다 품질이 좋은 해가 반드시 하나 이상 존재한다.
```

$A$보다 품질이 좋은 모든 해 $X$에 대해서 $w(A) < w(A')$이면서  
$|A' - X| = |A - X| - 1$이 되는 $A'$이 존재한다는 것이다.  
즉, $A$를 $X$ 방향으로 한 단계 이동시켜 $A$보다 품질이 좋은 해를 적어도 하나 찾을 수 있다는 것이다.  
따라서 이렇게 할 수 없는 해는 자신보다 품질이 좋은 해가 없는 해, 즉 최적해밖에 없다.  

```
매트로이드 $I$에서 $A \in I$와 인접한 해 중에 자신보다 품질이 더 좋은 해가 없으면
$A$는 (전역) 최적해이다.
```

위의 정리는 유용한 성질이다.  
어떤 해와 인접한 더 좋은 해가 없지만 인접 관계의 체인을 따라가다 보면  
더 좋은 해가 있을 수 있다는 가능성을 없애는 정리이기 때문이다.  
즉, 최적해보다 품질이 못한 지역 최적해는 존재할 수 ㅇ벗다는 것을 의미하기도 한다.  
가능한 봉우리는 최적해로 이루어진 봉우리뿐이다.

그렇다면 봉우리는 하나만 존재할 수 있는 것일까?  
같은 품질의 서로 다른 최적해로 이루어진 2개 이상의 봉우리는 없는 것일까?  
결론부터 이야기하자면 봉우리는 단 하나뿐이다.

```
매트로이드 $I$에서 서로 다른 두 (전역) 최적해 $A, B \in I$가 있다면
이들은 원소의 집합은 다르지만, 가중치의 집합은 동일하다.
```

즉, 어떠한 서로 다른 두 최적해 $A = {a_1, a_2, \cdots, a_n}, B = {b_1, b_2, \cdots, b_n}$  
에 대해서도 $w(a_1) = w(b_1), w(a_2) = w(b_2), \cdots, w(a_n) = w(b_n)$이다.  
$w(a_i) \ne w(b_i), w(a_j) \ne w(b_j)$이면서,  
$w(a_i) + w(a_j) = w(b_i) + w(b_j)$와 같이 되어 $A, B$의 품질이 같아지는 경우는 없다는 것이다.

```
서로 다른 어떤 두 최적해 $A, B \in I$든지 동일한 품질의 해들로 연결된 인접 관계의 체인을 따라 도달 가능하다.
```

$A$에서 $B$로 이동하는 과정은 교환성에 따라 설명될 수 있다.  
우선 $A, B \in I$이기 때문에 $A$에 $b_1$을 더하고 $a_i$를 제거하여  
$A \cup {b_1} - {a_i} \in I$를 만들 수 있다. 이를 $A'$라 하자.  
여기서 가중치 집합 $a = b$이기 때문에, $a_i = a_1 = b_1$이다.  
$A$가 최적해이고 $A'$도 또한 최적해이다.

즉, $A$는 $b_1$을 받아들이고 $b_1$과 가중치가 같은 자신의 원소 하나를 내보내는  
1회 교환으로 같은 품질의 인접한 다른 최적해 $A'$으로 이동할 수 있다.

이러한 교환 연산을 $A$부터 $A' \rightarrow A'' \rightarrow \cdots$을 거쳐  
$B$에 이를 수 있다. 그러므로 어떤 두 최적해든지 서로 간에 이런 이동이 가능하다.

이러한 앞선 정리로 인해 다음과 같은 정리도 가능하다
```
매트로이드 $I$에서 최적해를 이루는 봉우리는 단 하나 뿐이다.
```

모든 최적해는 서로 같은 품질의 인접성 체인을 따라 연결되므로  
최적해 봉우리는 단 하나뿐이다.

위의 정리들이 말하는 것은 임의의 해에서 시작해서  
더 좋은 인접해가 존재하기만 하면 그중 아무 것으로나 이동해도  
더 이상 이동할 수 없을 때까지 이동하기만 하면 최적해를 항상 찾게 되고  
그것이 유일한 봉우리에 속한다는 것이다.

