---
title: "자료구조 with Python : Part 7-3 해시 테이블 : 기타 해싱"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 헤시 테이블
  - 기타 해싱
  - 2-방향 체이닝
  - 뻐꾸기 해싱
  - 재해시
  - 동적 해싱
  - 확장 해싱
  - 선형 해싱
  - data structure
use_math: true
---

### 해시 테이블

#### 기타 해싱

##### 2-방향 체이닝<sup>Two-way Chaining</sup>
2-방향 체이닝은 2개의 해시함수를 이용하여 연결리스트의 길이가 짧은 쪽에 새 키를 저장한다.  
따라서 해시 테이블의 원소는 Node를 가리키는 레퍼런스 이외에도  
연결리스트의 길이를 가지고 있다.

2개의 해시함수 $h(key), d(key)$를 사용하여,  
두 개의 해시값에 해당되는 버켓에 있는 연결리스트의 길이 $a[h(key)], a[d(key)]$  
둘 중에 작은 쪽에 새로운 키를 추가한다. 추가한 이후 해당 연결리스트의 길이를 1 증가시킨다.

2-방향 체이닝은 2개의 해시 함수를 계산해야하고,  
연결리스트의 길이를 비교해야하며,  
추후에 탐색을 위해서는 두 연결리스트를 탐색해야 하는 경우도 발생한다.

그러나 연구 결과에 따르면,  
총 $N$개의 키를 2-방향 체이닝으로 저장하였을 때,  
연결리스트의 평균 길이는 $O(\log \log N)$으로 매우 짧아서  
실제로 매우 좋은 성능을 보인다.  


##### 뻐꾸기 해싱<sup>Cuckoo Hashing</sup>

뻐꾸기 해싱은 뻐꾸기가 다른 새의 둥지에 알을 낳고,  
부화된 뻐꾸기 새끼가 다른 새의 알이나 새끼들을 둥지에서 밀어내는 습성을 모방한 해싱 방법이다.  

* 2개의 해시함수와 각 함수에 대응되는 해시테이블을 이용해  
  충돌이 발생하면 그 곳에 있는 키를 쫓아내자

뻐꾸기 해싱은 2개의 해시함수와 2개의 해시테이블을 가지고  
키들을 ㅇ래의 알고리즘에 따라 저장한다.  
단, 해시함수 $h(key)$는 htable을 위한 것이고  
해시함수 $d(key)$는 dtable을 위한 것이다.  
그리고 new_key는 새로 삽입되는 키이다.  

알고리즘은 다음과 같다.
```
[1] key = new_key
[2] h(key) = i 를 계산하여, htable[i]에 key를 저장한다.

[3] if key가 저장된 원소가 비어있으면:
    삽입을 종료한다
[4] else: key가 저장돠면서 그 자리에 있던 키를 쫓아낸 경우
    key 때문에 쫓겨난 키를 old_key라고 하자.

[5] if old_key가 있었던 테이블이 htable이면:
    d(old_key) = j를 계산하여, dtable[j]에 old_key를 저장한다.
[6] else: old_key가 있었던 테이블이 dtable이면
    h(old_key) = j를 계산하여, htable[j]에 old_key를 저장한다.

[7] key = old_key, go to step [3]
```

새 키가 들어오게 되면,  
우선 i = h(key)를 계산하여 htable[i]에 저장하게 된다.  
이 때 htable[i]가 비어있으면, 해당 키를 삽입하고 종료하지만  

htable[i]에 이미 저장된 키가 있으면, 저장되어 있던 키를 old_key라 하고  
j = d(old_key)를 계산하여 dtable[j]에 old_key를 저장하고,  
새 키는 htable[i]에 저장한다.  

만약 저장하려더 새 키가 dtable[i]에 저장하는 것이였다면,  
j = d(old_key)를 계산하고 htable[j]에 old_key를 저장한다.  

뻐꾸기 해싱에서는 삽입 도중에 싸이클<sup>Cycle</sup>이 발생하면 삽입 과정이 종료되지 않는다.  
간단하게 새 키가 삽입되고 키을 연속해서 쫓아내다가 결국 삽입한 새 키를 다시 쫓아내고  
삽입 과정이 종료되지 않게 되는 것이다. 즉, NK->OK1->OK2->OK3->NK 식으로 밀어내는 과정이 반복되는 것이다.  
이러한 경우에는 재해시를 수행해야 한다.

뻐꾸기 해싱의 장점은 탐색과 삭제를 $O(1)$ 시간에 보장한다는 것인데,  
이런 장점을 갖는 해시함수는 아직 존재하지 않는다.  
즉, 최대 2회의 해시함수 계산으로 각각의 테이블 원소를 찾아 각 연산을 처리한다.  
단, 삽입은 높은 확률로 $O(1)$ 시간에 수행이 가능하다.  

##### 재해시<sup>Rehash</sup>
어떤 해싱 방법도 해시테이블에 비어있는 원소가 적으면,  
삽입에 실패하거나 해시 성능이 급격히 저하되는 현상을 피할 수 없다.  

이러한 경우 해시테이블을 확장시키고 새로운 해시함수를 사용하여  
모든 키들을 새로운 해시테이블에 다시 저장하는 **재해시**가 필요하다.  
재해시는 오프라인에서 이루어지고 모든 키들을 다시 저장해야 하므로,  
$O(N)$ 시간이 소요된다.

재해시의 수행여부는 **적재율**에 따라 결정된다.

`적재율 $\alpha$ = (테이블에 저장된 항목 수 N) / (테이블 크기 M)`

일반적으로 $\alpha \ge 0.75$가 되면 해시테이블 크기를 2배로 늘리고  
$\alpha \le 0.25$가 되면 해시테이블을 1/2로 줄인다.  


##### 동적 해싱<sup>Dynamic Hashing</sup>
동적 해싱은 대용량의 데이터베이스를 위한 해시방법으로  
재해시를 수행하지 않고 동적으로 해시테이블의 크기를 조절한다.  

대표적인 동적 해싱에는  
확장 해싱<sup>Extendible Hashing</sup>과 선형 해싱<sup>Linear Hashing</sup>이 있다.  

###### 확장 해싱
**확장 해싱**은 디렉터리를 주기억장치에 저장하고,  
데이터는 디스크 블록 크기의 버킷 단위로 저장한다.  
버킷에 오버플로우가 발생하면 새 버킷을 만들어 나누어 저장하며,  
이 때 이 버킷들을 가리키던 디렉터리는 2배로 확장된다.  

디렉토리는 깊이라는 변수를 가지는데,  
이 깊이에 따라 디렉토리의 크기가 결정된다.  
각 버킷에 데이터를 2개까지 삽입 가능하다고 가정하고  

예를 들어 8, 12, 7, 6, 5, 11, 3을 삽입한다고 하자.  
이 수들을 각각 이진수로 바꾸면, 1000, 1100, 0111, 0110, 0101, 1011, 0011이 된다.  
여기서 디렉토리의 깊이 비트만큼의 최우측 비트가 인덱스가 된다.  

초기에는 디렉토리 깊이를 1로 잡는다. 1비트에서는 0과 1만 쓸 수 있기 때문에  
2개의 버킷이 생성되고 디렉토리 깊이가 바뀌지 않고 들어갈 수 있는 데이터 양은 4개가 된다.  
처음 8(1000)이 삽입되면, 1000의 최우측 비트 0이 인덱스가 되고  
0번 디렉토리가 가리키는 버킷에 삽입된다.

다음 12(1100)도 똑같이 최우측 비트가 0이므로 0번 디렉토리가 가리키는 버킷에 삽입한다.

`
0[] -> [8, 12]
1[] -> [     ]
`

여기서 7(0111)을 삽입하면 최우측 비트가 1이므로 1번 디렉토리가 가리키는 버킷에 삽입한다.

`
0[] -> [8, 12]
1[] -> [7,   ]
`

그 다음 6(0110)을 삽입하면 최우측 비트가 0이므로 0번 디렉토리가 가리키는 버킷에 삽입한다.  
그런데, 버킷 안에 들어갈 수 있는 데이터가 2개가 넘어갔으므로 디렉토리의 크기를 2배로 하고  
버킷 안의 내용을 재조정한다. 여기서 오버플로우가 발생한 버킷에 대해서만 재조정해야한다.  

`
0[] -> [8, 12, 6] <- overflow
1[] -> [7,   ]
`

디렉토리의 크기를 2배로 늘린다는 뜻은 디렉토리의 깊이가 1 증가한다는 뜻이다.  
따라서 2비트, 00, 01, 10, 11 총 4개가 디렉토리가 된다.  
그 다음 포인터가 가리키는 테이블 값을 그대로 복사한다.  

`
00[], 10[] -> [8, 12, 6]
01[], 11[] -> [7,   ]
`

데이터의 해시값을 통해 데이터를 재조정한다. 필요한 경우 새 버킷을 만든다.  
새로 생성된 버킷이 있으면 해당 버킷에 대한 포인터로 변경한다  

`
00[] -> [8, 12]
01[], 11[] -> [7,   ]
10[] -> [6,   ]
`

오버플로우가 해결되면 종료하고, 그렇지 않으면 위의 과정을 반복한다.  
다음 5(0101)을 삽입하면 01[], 11[]가 가리키는 버킷에 저장된다  

`
00[] -> [8, 12]
01[], 11[] -> [7, 5]
10[] -> [6,   ]
`

다음 11(1011)을 삽입하면 01[], 11[]가 가리키는 버킷에 저장된다.

`
00[] -> [8, 12]
01[], 11[] -> [7, 5, 11] <- overflow
10[] -> [6,   ]
`

여기서 또 한번 오버플로우가 발생한다.  
그런데 앞서 오버플로우가 발생했을 때 디렉토리의 크기를 늘렸었지만,  
같은 곳을 가리키는 디렉토리의 비트로 데이터를 분류할 수 있으면 늘릴 필요가 없다.  
즉 7은 0111, 5는 0101, 11은 1011이므로  
7과 11은 11[]에 저장할 수 있고 5는 01[]에 저장할 수 있다.  
따라서 버킷이 하나 더 생성되고 분류에 맞게 포인터도 변경된다.  

`
00[] -> [8, 12]
01[] -> [5,   ]
10[] -> [6,   ]
11[] -> [7, 11]
`

마지막으로 3(0011)을 삽입해 보면

`
00[] -> [8, 12]
01[] -> [5,   ]
10[] -> [6,   ]
11[] -> [7, 11, 3] <- overflow
`

보이는 것처럼 오버플로우가 발생한다.  
분류할 수 있는 디렉토리가 따로 없기 때문에 디렉토리의 크기를 2배로 늘린다.  
그렇게 되면 3비트 000, 001, 010, 100, 011, 110, 101, 111으로 인덱스가 늘어난다.  
그 다음 오버플로우된 버킷만 재조정한다.  

`
000[], 100[] -> [8, 12]
001[], 101[] -> [5,   ]
010[], 110[] -> [6,   ]
011[], 111[] -> [7, 11, 3] <- overflow => 011[] -> [11, 3]
                                       => 111[] -> [7,   ]
`

디렉터리의 깊이만큼의 최우측 비트를 통해 탐색, 삽입, 삭제 연산을 수행한다.

###### 선형 해싱
디렉터리 없이 삽입할 때 버킷을 순서대로 추가하는 방식이다.  
추가되는 버킷은 삽입되는 키가 저장되는 버킷과 무관하게 순차적으로 추가된다.  
만일 삽입되는 버킷에 저장공간이 없으면 overflow 체인에 새 키를 삽입한다.  
체인은 단순연결리스트로서 overflow된 키들을 임시로 저장하고,  
나중에 관련된 버킷이 추가되면 overflow 체인의 키들을 버킷으로 이동한다.  

예를 들어, 8, 12, 7, 6, 5, 11, 3을 선형 해싱을 통해 저장한다고 생각해보자.  
위의 숫자들을 이진수로 바꾸면 1000, 1100, 0111, 0110, 0101, 1011, 0011이다.  
위의 숫자들을 삽입하는 과정은 다음과 같다.  

`  
0[8,]  => 0[8, 12] => 0[8, 12]    0[8, 12] -> [6]  
                      1[7,   ] => 1[7,   ]  
`  

위의 과정까지는 오버플로우가 발생하면 바로 뒤에 해당 키를 저장하는 오버플로우 체인을 만든다.    
그리고 그 다음에는 0(00)번 인덱스를 2비트로 나누어 재분배를 실시한다.    

`  
00[8, 12]    00[8, 12]    00[8, 12]  
01[7,   ] => 01[7,  5] => 01[7,  5] -> [11]  
10[6,   ]    10[6,   ]    10[6,   ]  
`  

위의 과정까지 앞서 발생한 오버플로우에 대응하는 과정과 동일하다.    
단 인덱스의 분리는 0번부터 순차적으로 이루어져야 한다.    
이미 0(00)번 인덱스는 되어 있기 때문에 1(01)번 인덱스를 분리하고 재분배를 실시한다.   
 
`  
00[8, 12]    00[8, 12]  
01[7,  5]    01[7,  5]  
10[6,   ] => 10[6,   ]  
11[11,  ]    11[11, 3]  
`  

으로 삽입 연산은 종료가 된다.  
  
위의 과정은 간략하게 설명되어 있는 것이다.  
선형 해싱은 디렉터리를 사용하지 않는 장점을 가지고 있으며,  
인터렉티브 응용에 적합하다.  