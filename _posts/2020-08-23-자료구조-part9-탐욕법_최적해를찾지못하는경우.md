---
title: "자료구조 with Python : Part 9-1 탐욕 알고리즘 : 최적해를 보장받지 못하는 경우"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 탐욕 알고리즘
  - 탐욕법
  - Greedy Algorithm
  - data structure
use_math: true
---

### 탐욕 알고리즘<sup>Greedy Algorithm</sup>

#### 최적해를 보장되지 않는 예

##### 이진 트리의 최적합 경로 찾기

```
                    10
                 :/    \\
                15      60
              /   :\      \\
            18     30       2
           /     /    :\
          3    35      45
                     /:   \
                   67      55
```

위의 이진트리가 존재한다고 해보자.  
탐색을 하기 전에는 위의 트리의 내용은 알지 못하며,  
분기를 정하여 임의의 노드에 방문해야 해당 노드의 가중치가 밝혀진다.  
트리의 루트에서부터 분기를 타고 내려가 리프 노드에 도착하면 알고리즘은 종료가 되며,  
이 과정에서 밝혀진 노드들의 가중치 합이 이 경로의 점수라고 하면  
이 점수가 최대치가 되도록 하는 알고리즘을 찾아야 한다. 

이러한 문제는 탐욕 알고리즘의 구조를 통해 최적해를 찾아낼 수 없다.  
만약 탐욕 알고리즘을 통해 해를 구하게 된다면,  
`\\`의 간선을 따라 10, 60, 2의 합 72를 해로 낸다.

그러나 DFS나 BFS와 같은 방식으로 모든 정점을 탐색해야  
`:\`의 간선처럼 최대의 가중치 합을 구할 수 있다.

##### 0/1 보따리 문제<sup>0/1 Knapsack Problem</sum>

부피가 $M$인 보따리와 이 보따리에 넣으려 하는 $n$개의 물건이 있다.  
물건 $i$의 부피는 $W_i$이고 이것을 보따리에 넣을 경우 $P_i$의 가치가 있다.  
물건들의 전체 부피 합이 $M$을 넘지 않도록 하면서, 가치가 최대가 되도록  
보따리에 물건을 넣는 알고리즘은 무엇일까?

사실상 이 문제는 나중에 이야기할 NP-Hard에 속하는 난제이다.  
탐욕 알고리즘으로는 보따리 용량을 초과하지 않은  
한 단위 부피당 가치가 가장 큰 물건 순서로 각 물건을 보따리에 추가한다.  
이 방식의 탐욕 알고리즘은 최적해를 보장하지 못한다.

```
Greedy_Knapsack(P, W, M):
    P = 가치 배열, W = 부피 배열
    X = 보따리에 담는 물건 집합, M = 보따리 부피
    P와 W를 P[i]/W[i]의 내림차순으로 정렬한다.
    LR = M
    i = 0
    X = []
    while W[i] <= LR and i <=n:
        X <- X + i
        LR <- LR - W[i]
        i += 1\
    return X
```

만약 이 보따리 문제에서 물건을 자를 수 있다면  
이 같은 방식으로 최적해를 보장할 수 있다.  
즉 단위 부피당 가치가 가장 큰 물건 순서로 각 물건을 보따리에 추가하다가  
어떤 물건을 넣으려는 순간 보따리 용량을 초과하면 남은 용량에 들어갈 만큼만 잘라넣으면 된다.  
그러면 최적해가 된다.

이 유형의 보따리 문제를 자를 수 있는 보따리 문제<sup>Fractional Knapsack Problem</sup>라 한다.

##### 동전 바꾸기

우리나라에 예를 들어 500원, 100원, 50원, 10원, 5원, 1원이 있다고 하자.  
3,256원을 가장 적은 개수의 동전을 사용해 만들려면  
먼저 500원을 쓸 수 있는 데까지 쓰면 6개가 된다.  
다음은 100원 2개, 50원 1개, 5원 1개, 1원 1개로 하면,  
총 11개의 동전으로 3,256원을 만들 수 있다. 이 것은 최적해다.  

이처럼 동전의 액면이 커지면서 바로 아래 액면의 배수가 되는 경우에는  
그리디한 방식으로 최적해를 구할 수 있다.

반면에 동전의 액면이 증가하면서 앞 액면의 배수가 되지 않는 경우에는 그리디한 방법으로  
최적해가 보장되지 않는다.

예를 들어 500원, 400원, 100원, 75원, 50원이라 하고 1300원을 만들어 보자.  
그리디하게 개수를 구해보면, 500원 2개, 100원 3개로 총 5개의 동전을 사용하게 된다.  
그러나 최적해는 500원 1개, 400원 2개 총 3개의 동전이다.

이 문제는 동적 프로그래밍으로 최적해를 찾아낼 수 있다.  
즉 가능한 모든 경우의 수를 따져 최적해를 찾아낸다.