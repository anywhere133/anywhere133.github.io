---
title: "자료구조 with Python : Part 8-1 그래프 탐색"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 그래프
  - data structure
use_math: true
---

### 그래프

#### 그래프 탐색

그래프에서 모든 정점을 방문해야 하는 경우가 있다.  
그 방법은 다양하지만 대표적으로 너비 우선 탐색<sup>BFS, Breadth-First Search</sup>과  
깊이 우선 탐색<sup>Depth-First Search</sup>이다.  
두 방법은 매우 간단하지만 그래프 알고리즘에서 핵심적 위치를 차지한다.

실질적으로 이진 트리에서 전위 순회와 레벨 순회와 같다.  
너비 우선 순회는 레벨 순회와 동일하고, 깊이 우선 순회는 전위 순회와 동일하다.

##### 그래프에서의 깊이우선탐색

임의의 정점에서 시작하여 이웃하는 하나의 정점을 방문하고,  
방금 방문한 정점의 이웃 정점을 방문하며, 이웃하는 정점들을 모두 방문한 경우에는  
이전 정점으로 되돌아가서 탐색을 수행하는 방식으로 진행된다.  

DFS는 실타래를 가지고 미로에서 출구를 찾는 것과 유사하다.  
새로운 곳으로 갈 때는 실타래를 풀면서 진행하고,  
길이 막혀 진행할 수 없을 때에는 실타래를 되감으며 왔던 길을 되돌아가서  
다른 경로를 탐색하여 출구를 찾는다.

다음은 DFS를 파이썬으로 구현한 코드이다.
```python
def dfs(v):
    visited[v] = True
    print(v, ' ', end='')
    for w in adj_list[v]:
        if not visited[w]:
            dfs(w)

for i in range(N):
    if not visited[i]:
        dfs(i)
```

그래프 인접리스트의 길이만큼 `visited = [False] * N`의 리스트를 만든다.  
시작 정점 v에서부터 탐색을 시작하여, 같은 인덱스의 visited를 True로 바꾼다.  
그리고 v와 인접한 정점을 `dfs()` 재귀호출한다.  

탐색과정에서 밝혀진 간선은 발견 간선 혹은 트리 간선이라고 한다.  
그 외의 탐색과정에서 밝혀지지 않은 간선은 논트리 간선이라고 한다.  
이 논트리 간선은 이전에 탐색된 간선을 방문하게 한다.  
이렇게 DFS를 수행하며 트리 간선으로 만들어지는 트리를 깊이우선 신장트리라고 한다.  

이 중에서 무향 그래프에서 만들어진 깊이우선 신장트리에서의 논트리 간선들은  
모두 다 뒷간선<sup>Back Edge</sup>이다.  
뒷간선은 부모 관계가 아닌, 조상 관계의 두 정점을 잇는 간선이다.  

반면 유향 그래프에서 만들어진 깊이 우선 신장트리에서의 논트리 간선들은  
세 가지 종류가 가능하다.  
* 뒷간선<sup>Back Edge</sup> : DFS 트리에서 정점을 조상과 연결하는 간선 (부모 포함)  
* 앞간선<sup>Forward Edge</sup> : DFS 트리에서 정점을 후손과 연결하는 간선 (자식 포함)  
* 교차간선<sup>Cross Edge</sup> : DFS 트리에서 후손이나 조상이 아닌 정점과 연결하는 간선  


###### DFS의 수행시간

탐색은 각 정점을 한 번씩 방문하며, 각 간선을 한 번씩만 사용하여 탐색하기 때문에  
$O(N+M)$이다. 여기서 $N$은 그래프의 정점 수이고, $M$은 간선의 수이다.


##### 그래프에서의 너비우선탐색

임의의 정점 $s$에서 시작하여 $s$의 이웃하는 모든 정점들을 방문하고,  
방문한 정점들의 이웃 정점들을 방문하는 방식으로 그래프의 모든 정점을 방문한다.  

BFS는 연못에 돌을 던졌을 때 물결이 동심원을 그리며 퍼져나가는 모양으로 정점들을 방문한다  

파이썬으로 구현한 코드는 다음과 같다. 단, 이진트리의 레벨순회에서처럼 큐를 사용한다.  
```python
def dfs(i):
    queue = []
    visited[i] = True
    queue.append(i)
    while len(queue) != 0:
        v = queue.pop(0)
        print(v, ' ', end='')
        for w in adj_list[v]:
            if not visited[w]:
                visited[w] = True
                queue.append(w)

for i in range(N):
    if not visited[i]:
        dfs(i)
```

위의 코드는 아래의 for 문을 통해 모든 노드를 방문할 수 있게 해준다.  
`dfs()`에서 while 문에서는 해당 정점과 연결되어 있는 모든 정점들을 방문하게 해준다.  
만약 그래프 인접리스트에서 분리된 그래프가 있으면 for 문이 꼭 필요하다.  

깊이우선 신장트리처럼 DFS를 통해 트리 간선으로 만들어진 트리를  
너비우선 신장트리<sup>Breadth Fisrt Spanning Tree</sup>라고 한다.  

###### BFS의 수행시간

BFS는 DFS와 같이 각 정점을 1번씩 방문하며, 각 간선을 1번씩만 사용하여  
탐색하기 때문에 $O(N+M)$의 수행시간이 소요된다.  
BFS와 DFS는 정점의 방문 순서나 간선을 사용하는 순서만 다를 뿐이다.  


#### DFS와 BFS로 수행 가능한 그래프 응용

|    응용     |     DFS     |     BFS      |
|:----------:|:-----------:|:------------:|
| 신장트리, 연결성분, 경로, 싸이클     | O | O |  
| 최소 간선을 사용하는 경로           | X | O |  
| 위상정렬, 이중연결성분, 강연결성분    | O | X |  

