---
title: "자료구조 with Python : Part 8-4 최단 경로 : 플로이드-워셜"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 그래프
  - 최단 경로
  - 플로이드-워셜 알고리즘
  - Floyd-Warshall Algorithm
  - 모든 쌍 최단 경로 알고리즘
  - 이행적 폐쇄
  - Transitive Closure
  - 접근 가능성
  - data structure
use_math: true
---

### 그래프

#### 최단 경로<sup>Shortest Paths</sup>

##### 플로이드-워셜 알고리즘<sup>Floyd-Warshall Algorithm</sup>

다익스트라와 벨만-포드 알고리즘은 단일한 시작 정점에서 다른 정점들로 가는 최단경로를 구하는 것이다.  
플로이드-워셜 알고리즘은 자기 자신을 포함한 모든 정점 쌍 사이의 최단 경로를 구한다.  
즉, 구해야 하는 최단 경로가 모두 $n^2$개이다.  

우선 벨만-포드 알고리즘의 단순 연장선 상에 있는 방법에 대해 알아보자.  
변수 $d_{ij}^m$를 다음과 같이 정의한다.  

$d_{ij}^m$ : 최대 $m$개의 간선을 사용해서 정점 $i$에서 정점 $j$에 이르는 최단 거리  

그러면 점화식은 다음과 같다.

$$d_{ij}^m =
\begin{cases}
w_{ij}     & \text{if $m = 1$} \\
\min_{1 \le k \le n} \{d_{ik}^{m-1} + w_{kj}\}    & \text{if $m \ge 2$}
\end{cases}$$

최대 $m$개의 간선을 사용해서 정점 $i$에서 정점 $j$에 이르는 최단 거리 $d_{ij}^m$을 구하기 위해서는,  
모든 정점   대해 최대 $m-1$개의 간선을 사용해서 정점 $i$에서 정점 $k$에 이르는  
최단거리 $d_{ik}^{m-1}$에다 $w_{kj}$를 더한 값을 구한 다음 이 중 가장 짧은 것을 택한다.  

그러나 이러한 방법의 수행시간은 $O(n^4)$ 시간이 걸린다.  

다음 플로이드-워샬 알고리즘은 이를 $O(n^2)$ 시간에 해결한다.  
이번에는 $d_{ij}^k$를 다음과 같이 정의한다.

$d_{ij}^k$ : 정점 집합 {1, 2, ..., k}에 속하는 정점들만 중간 정점으로 거쳐서 $i$에서 $j$에 이르는 최단 거리  

앞에서의 정화식은 간선의 수와 관계지어 변수를 정의했으나,  
여기서는 사용한 정점의 집합과 관계를 짓는다. 점화식은 다음과 같다.

$$d_{ij}^k =
\begin{cases}
w_{ij}     & \text{if $k = 0$} \\
\min ({d_{ij}^{k-1}, d_{ik}^{k-1} + d_{kj}^{k-1}})    & \text{if $k \ge 1}
\end{cases}$$

$d_{ij}^k$는 정의에 따라 정점 집합 {1, 2, ..., k}에 속하는 정점만을 거쳐서  
$i$에서 $j$에 이르는 최단거리다. 경로 $p$를 이런 최단 경로라 하자.

* 경로 $p$에 정점 $k$가 포함되어 있다면,  
  정점 $k$를 중심으로 경로 $i \to k$와 $k \to j$로 나누어보자.  
  최단 경로상 사이클은 존재할 수 없으므로, 두 경로 중간에 정점 $k$는 더 이상 나타나지 않는다.  
  즉, 이 두 경로는 각각 정점 집합 {1, 2, ..., k-1}에 속하는 정점만을 거치는 최단경로 $i \to k$와  
  정점 집합 {1, 2, ..., k-1}에 속하는 정점만을 거치는 최단 경로 $k \to j$가 되어  
  각각의 길이는 $d_{ik}^{k-1}$와 $d_{kj}^{k-1}$가 된다.  
  
* 경로 $p$에 정점 $k$가 포함되어 있지 않으면,  
  이 경로는 정점 집합 {1, 2, ..., k-1}에 속하는 정점만을 사용한다.  
  즉, $d_{if}^k = d_{ij}^{k-1}$이다.

즉, 경로 $i \to j$를 위한 위의 두 경우 중 작은 것이 $d_{ij}^k$가 된다.

이를 파이썬 코드로 구현하면 다음과 같다.
```python
import copy

def Floyd_Warshall(g):
    dist = {v : dict.fromkeys(g.vertices(), float('inf')) for v in g.vertices()}
    prev = {v : dict.fromkeys(g.vertices(), None) for v in g.vertices()}

    for i in g.vertices():
        for j in g.vertices():
            if i == j:
                dist[i][j] = 0
                prev[i][j] = None
            else:
                e = g.get_edge(i, j)
                dist[i][j] = e.element()
                prev[i][j] = j

    for k in g.vertices():
        for i in g.vertices():
            for j in g.vertices():
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    prev[i][j] = prev[i][k]

    return dist, prev
```

##### 플로이드-워샬 알고리즘의 수행시간 분석

먼저 수행시작을 말하자면, $O(n^3)$ 시간에 알고리즘은 작동된다.  
위의 구현된 알고리즘을 보면, 삼중으로 for 문으로 이루어져 있다.  
모든 정점의 수만큼 각 for 문이 반복되므로 $O(n^3)$ 시간이 소요된다.  

플로이드-워샬 알고리즘은 최단 거리를 구하는 방법으로도 사용되지만,  
각 정점간 접근 가능성을 구하는 방법으로도 사용된다.  
즉 이행적 폐쇄를 구하는 데에 사용된다.

이행적 폐쇄<sup>Transitive Closure</sup>란,  
어떤 정점 $i$에서 $j$로 가는 방향에 대해 직접 경로는 없지만,  
$k$를 통한 간접 경로가 있을 때 $i \to j$로의 간선으로 연결한 그래프이다.  
즉 간접 경로 $i \to k$와 $k \to j$가 있을 때,  
두 경로의 길이의 합만큼을 길이로 갖는 직접 경로 $i \to j$를 만든다.

여기서 깊이우선탐색<sup>DFS</sup>을 통해서도 접근 가능성을 구할 수 있는데,  
모든 정점에 대해 시작점으로 탐색을 하여 동일한 결과를 얻을 수 있다.  
이 경우 $O((n+m)*n)$ 시간에 수행이 완료된다.

일반적으로 플로이드-워샬 알고리즘이 DFS보다 수행시간 면에서 더 낫지는 않지만,  
그래프가 조밀하거나, 그래프가 희소하지만 인접 행렬로 표현된 경우에는  
수행시간이 DFS에 점근적으로 일치해진다.

그리고 플로이드-워샬 알고리즘의 중요한 점은 DFS보다 구현하기 더 쉽고,  
점근 표기법 안에 숨겨진 상대적으로 적은 로우레벨 연산들 때문에 실제로는 더 빠르다는 점이다.  
또 인접 행렬의 사용에 잘 맞는다.

그러나 그래프가 희소하고 인접 리스트나 인접 맵으로 표현될 때는  
DFS의 결과가 더 나은 점근적 수행을 보인다.  
앞서 말했듯 $O((n+m)*n) = O(n^2 + mn)$ 시간에 수행된다.
