---
title: "자료구조 with Python : Part 2"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 수행시간 분석
  - 복잡도
  - data structure
use_math: true
---

### 수행시간 분석

자료구조의 효율성은 자료구조에 대해 수행되는 연산의 수행시간으로 측정할 수 있다.
자료구조에 대한 연산 수행시간 측정 방식은 알고리즘의 성능을 측정하는 방식과 동일하다.

알고리즘의 성능은 수행시간을 나타내는 시간복잡도<sup>Time Complexity</sup>와
알고리즘이 수행되는 동안 사용되는 메모리 공간의 크기를 나타내는 공간복잡도<sup>Space Complexity</sup>에 기반하여 분석한다.

대부분 시간복잡도만을 사용해 알고리즘의 성능을 분석하는데, 대부분의 알고리즘들이 비슷한 크기의 메모리 공간을 사용하기 때문이다.

알고리즘의 성능은 알고리즘을 구현한 프로그램을 실제로 컴퓨터에서 실행시킨 후 실행 완료까지 소요된 시간으로 측정할 수 있다.
하지만 실제 측정된 시간으로는 알고리즘의 성능을 객관적으로 평가하는 데는 한계가 존재.
왜냐하면 프로그래머의 숙련도, 구현에 사용된 프로그래밍 언어의 종류 그리고 알고리즘을 실행한 컴퓨터의 성능에 따라
수행시간은 얼마든지 달라질 수 있기 때문이다.

따라서 알고리즘의 시간복잡도는 알고리즘이 실행되는 동안에 사용된 기본적인 연산 횟수를 입력 크기의 함수로 나타낸다.

* 기본 연산<sup>Elementary Operation</sup>
  - 데이터간 크기 비교, 데이터 읽기 및 갱신, 숫자 계산 등과 같은 단순한 연산을 의미

알고리즘의 수행시간은 다음 세 가지 방법으로 분석한다.

1. 최악경우 분석 (Worst-case Analysis)
2. 평균경우 분석 (Average-case Analysis)
3. 최선경우 분석 (Best-case Analysis)

일반적으로 알고리즘의 수행시간은 최악경우 분석으로 표현한다.
최악경우 분석은 '어떤 입력이 주어지더라도 알고리즘의 수행시간이 얼마 이상은 넘지 않는다'라는
상한<sup>Upper Bound</sup>의 의미를 갖는다.
평균경우 분석은 입력의 확률 분포를 가정하여 분석하는데, 일반적으로 균등 분포를 가정한다.
즉, 입력이 무작위로 주어진다고 가정한다.
최선경우 분석은 가장 빠른 수행시간을 분석하는 것이다. 거의 사용되지 않지만, 최적 알고리즘을 찾는데 활용된다.


### 수행시간의 점근표기법

수행시간은 알고리즘이 수행하는 기본 연산 횟수를 입력 크기에 대힌 함수로 표현한 것이다.
이 함수는 주로 여러 개의 항을 가지는 다항식으로 표현되므로
이를 입력의 크기에 대한 함수로 표현하기 위해 점근표기법<sup>Asymptotic Notation</sup>이 사용된다.

주로 세 가지 점근표기법이 사용된다.

1. O (Big-oh)-표기법
2. $\Omega$ (Big-Omega)-표기법
3. $\Theta$ (Big-Theta)-표기법

* O-표기의 정의
  * 모든 N $\ge$ N<sub>0</sub>에 대해서 $f(N) \le cg(N)$이 성립하는
    양의 상수 c와 N<sub>0</sub>이 존재하면, $f(N) = O(g(N))$이다.

O-표기의 의미는 N<sub>0</sub>과 같거나 큰 모든 N(즉, N<sub>0</sub> 이후의 모든 N)에 대해서
$f(N)$이 $cg(N)$보다 크지 않다는 것이다.
따라서 $f(N) = O(g(N))$은 N<sub>0</sub>보다 큰 모든 N에 대해서 $f(N)$이 양의 상수를 곱한 $g(N)$에 미치지 못한다는 뜻이다.
여기서 $g(N)$을 $f(N)$의 상한<sup>Upper Bound</sup>이라 한다.

$f(N) \le cg(N)$을 만족하는 $g(N)$은 많을 수 있다.
예를 들어, $f(N) = 2N^2 + 3N + 5$라면, $g(N)$은 N<sup>2</sup>이 될 수도, 2<sup>N</sup>이 될 수도 있다.
그러나 $g(N)$을 선택할 때에는 정의를 만족하는 가장 차수가 낮은 함수를 선택하는 것이 바람직하다.

간단하게 O-표기를 찾기 위한 방법은 $f(N)$의 계수를 제거한 최고 차수 항을 $g(N)$으로 보는 것이다.
예를 들면, $f(N) = 2N^2 + 3N + 5$라면 $g(N) = N^2$이 된다.


* $\Omega$-표기의 정의
  * 모든 N $\ge$ N<sub>0</sub>에 대해서 $f(N) \ge cg(N)$이 성립하는 양의 상수 c와 N<sub>0</sub>이 존재하면,
    $f(N) = O(g(N))$이다.

$\Omega$-표기의 의미는 N<sub>0</sub>보다 큰 모든 N에 대해서 $f(N)$이 $cg(N)$보다 작지 않다는 것이다.
즉 $f(N) = \Omega(g(N))$은 양의 상수를 곱한 $g(N)$이 $f(N)$에 미치지 못한다는 뜻이다.
여기서 $g(N)$을 $f(N)$의 하한<sup>Lower Bound</sup>이라고 한다.

$f(N) \ge cg(N)$을 만족하는 $g(N)$은 많을 수 있다.
예를 들어, $f(N) = 2N^2 + 3N + 5$라면, $g(N)$은 $N$이 될 수도, $logN$이 될 수도 있다.
그러나 $g(N)을 선택할 때에는 정의를 만족하는 가장 차수가 높은 함수를 선택하는 것이 바람직하다.

$\Omega$-표기를 찾는 방법은 O-표기를 찾은 방법과 동일하다.
간단하게 $f(N)$의 계수를 제거한 최고 차수 항을 $g(N)$으로 보는 것이다.


* $\Theta$-표기의 정의
  * 모든 $N \ge N_{0}$에 대해서 $c_{1}g(N) \ge f(N) \ge c_{2}g(N)$이 성립하는 양의 상수 $c_{1}, c_{2}, N_{0}$이 존재하면,
    $f(N) = \Theta(g(N))$이다.

$\Theta$-표기는 수행시간의 O-표기와 $\Omega$-표기가 동일한 경우에 사용한다.
따라서 $2N^2 + 3N + 5 = O(N^2)$과 동시에 $2N^2 + 3N + 5 = \Omega(N^2)$이므로,
$2N^2 + 3N + 5 = \Theta(N^2)$이다.
$\Theta(N^2)$은 $N^2$과 $2N^2 + 3N + 5$가 유사한 증가율울 가지고 있다는 뜻이다.
따라서 $2N^2 + 3N + 5 \not= \Theta(N^3)$이고, $2N^2 + 3N + 5 \not= \Theta(N)$이다.


알고리즘의 수행시간은 주로 O-표기를 사용하며, 보다 정확히 표현하기 위해 $\Theta$-표기를 사용하기도 한다.

![함수의 증가율 비교](https://raw.githubusercontent.com/anywhere133/anywhere133.github.io/master/_posts/picture/Figure_1.png)
