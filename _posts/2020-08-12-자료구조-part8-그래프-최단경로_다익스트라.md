---
title: "자료구조 with Python : Part 8-4 최단 경로 : 다익스트라"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 그래프
  - 최단 경로
  - 다익스트라 알고리즘
  - Dijkstra's Algorithm
  - 알고리즘
  - Algorithm
  - data structure
use_math: true
---

### 그래프

#### 최단 경로<sup>Shortest Paths</sup>

##### 다익스트라 알고리즘<sup>Dijkstra's Algorithm</sup>

다익스트라 알고리즘은 탐욕법<sup>Greedy Method</sup> 패턴을 적용한 알고리즘이다.

처음 시작 정점에서부터 집합, 다르게 말해 구름을 만들어나가는데,  
반복적으로 구름 밖에 존재하는 가장 가까운 거리의 정점을 구름에 포함시켜나간다.  
이는 최소신장트리를 만드는 프림 알고리즘과 거의 동일한 골격임을 확인할 수 있다.

먼저 파이썬으로 구현된 코드를 살펴보자.
```python
def shortest_path_lengths(g, src):
    d = {}
    cloud = {}
    pq = AdaptableHeapPriortyQueue()
    pqlocator = {}

    for v in g.vertices():
        if v is src:
            d[v] = 0
        else:
            d[v] = float('inf')
        pqlocator[v] = pq.add(d[v], v)

    while not pq.is_empty():
        key, u = pq.remove_min()
        cloud[u] = key
        del pqlocator[u]
        for e in g.incident_edges(u):
            v = e.opposite(u)
            if v not in cloud:
                wgt = e.element()
                if d[u] + wgt < d[v]:
                    d[v] = d[u] + wgt
                    pq.update(pqlocator[v], d[v], v)
    return cloud
```

프림 알고리즘과 유일하게 다른 점은 최소힙을 갱신하는 부분이다.  

이를 간선 완화<sup>Edge Relaxation</sup> 절차라고 하는데  
새 정점이 구름에 추가되었을 때 초기 정점부터 각 정점까지의 거리를  
더 가까운 값으로 변경할 수 있을 때 실시된다.

```python
if d[u] + wgt < d[v]:
    d[v] = d[u] + wgt
    pq.update(pqlocator[v], d[v], v)
```

구름 안에 포함되어 있는 $u$와 연결되어 있는 각 정점 $v$의 거리 d[v]에 대해  
갱신되지 않은 d[v]가 d[u]에 $e(u, v)$보다 크면, $d[v] + e(u, v)$의 값으로 갱신해야 한다.  
따라서 초기 정점부터 각 정점까지의 거리를 저장하는 딕셔너리 d에는 최소거리들로만 저장된다.  

위의 간선 이완 절차는 정점이 구름에 새로 추가될 때마다 시행된다.  
새 정점이 구름에 추가되므로써, 연결되지 못했던 정점들이 구름에 포함될 수 있게 된다.  
닿지 못하는 정점들의 거리는 $\infty$이기 때문에, 무조건 거리의 갱신이 필요하다.  
갱신이 되어 있던 정점도 구름에 새로 추가된 정점으로 인해 갱신이 될 수 있다.

최소신장트리를 구하는 프림의 경우에는  
각 간선이 가지고 있는 가중치들은 갱신되지 않기 때문에  
구름에 닿아있는 외부의 정점들의 간선들 중에서 제일 작은 간선을 선택해나가면 되지만,

최단경로트리를 구하는 다익스트라의 경우에는  
최초 정점부터 각 정점까지의 거리, 개별 간선의 가중치가 기준이 아니라  
각 정점까지에 존재하는 경로의 가중치 합이 최소가 되도록 트리를 키워나간다.

즉 다익스트라의 경우에는 노드 사이에 최단 거리를 구하고,  
프림의 경우에는 전체 노드의 가중치 총합이 최소가 되는 트리를 구한다.

이 차이에서 두 알고리즘이 트리를 만든다고 하면,  
항상 같은 트리를 만든다고는 볼 수 없다.

프림이 만드는 최소신장트리는 두 노드 사이가 최단거리가 아닐 수 있다.  
또 프림은 무향 그래프에서만 작동하고, 다익스트라는 유향, 무향 그래프 모두에서 작동한다.  
마지막으로 최소신장트리가 최단거리를 보장하지 않기 때문에,  
프림이 다익스트라를, 다익스트라가 프림을 보장해 주지 않는다.


그렇다면, 다익스트라는 왜 제대로 작동되는 것인가?  
이는 그래프에 음의 가중치를 가지는 간선이 존재 여부에 달려있다.  

만약 시작 정점 $s$부터 어떠한 정점 $z$으로의 최단 경로가 존재한다면,  
그 경로의 끝 정점 $z$의 이전 단계에 있는 정점 $y$와 시작 정점 $s$ 사이의 경로도 최단경로이다.  

만약, 경로 $d(s, z)$가 최단 경로가 아니라면  
끝 정점과 이전 단계 정점을 잇는 간선의 거리 w(y, z)와  
이전 단계 정점의 최단 경로 $d(s, y)$를 합한 경로가  
현재의 거리 $D[z]$보다 더 짧음

$$D[z] \ge d(s, y) + w(y, z)$$  

따라서 시작 정점으로부터 끝 정점까지의 경로가 최단경로라는 가정에 모순이 발생하게 된다.  

위의 증명에 의해,  
현재까지 밝혀진 최단경로를 찾은 정점들과 바로 이어진 다른 정점으로의 간선을 이은 경로들 중에는  
반드시 최단 경로임이 보장되는 정점이 하나 이상 존재한다.

또 현재까지 최단 경로를 찾은 정점들로부터 바로 이어진 다른 정점으로의 간선을 이은 경로들을 찾은 후,  
아직 최단경로를 찾지 못한 정점들 중에서 시작점과의 거리가 가장 작은 정점이 다음 최단 경로이다.  

위의 증명들은 기본적으로 그래프 내의 간선들의 가중치들이 0 이상이라고 가정하고 있는 것이다.  
만약 음수 가중치를 갖는 간선이 그래프에 존재한다면, 위의 경우가 발생할 수 있기 때문이다.

##### 다익스트라 알고리즘의 수행시간

유향 그래프 $G$가 정점 $n$개와 간선 $m$개로 이루어져 있다고 하자. 

간선에서의 가중치는 상수 시간에 합 연산과 비교 연산이 가능하다. 

그 외에는 알고리즘에 사용된 자료구조와 그것이 어떻게 구현되었는지가 중요하다.

다익스트라 알고리즘에서는 인접 리스트나 인접 맵을 사용하여 구현하는 것이 효과적이다.  
인접 리스트를 통해 정점 $u$와 인접하고 있는 정점들을 그 수에 비례하여 처리하는 것이 가능해진다.

그리고 여기서 적용된 적응형 우선순위 큐의 삽입, 삭제, 수정 연산을 통해 알고리즘이 작동한다.

삽입, 삭제, 수정 연산의 수행 시간은 $O(\log n)$이 걸린다.  
그런데, $n$개의 정점에 대해 삽입 연산이 수행되고  
$n$개의 정점에 대해 삭제 연산이 수행되고,  
마지막으로 $m$개의 간선에 대해 수정 연산이 수행된다.

즉, 우선순위 큐에 삽입하는 첫 번째 for 문에서는 $O(n \log n)$ 시간이 소요되고,  
while 문 내의 for 문에서 $m$개의 간선에 대한 수정 연산이 수행되기 때문에,  
$O(m \log n)$ 시간이 소요된다.  
마지막으로 while 문에서의 삭제 연산은 $O(n \log n)$ 시간이 소요된다.

따라서 전체 알고리즘에서의 수행시간은 $O((n+m) \log n)$ 시간이 소요된다.

이와 반대로 정렬되지 않은 배열을 사용하는 경우에는  
최소값을 탐색하는 연산의 수행시간은 $O(n)$시간이,  
키를 수정하는 연산의 수행시간은 $O(1)$시간이 소요된다.

따라서 각 for문과 while문을 통해 보았을 때,  
전체 수행시간은 $O(n^2 + m)$ 시간이 소요된다고 볼 수 있다.  
다시 말하면, $O(n^2)$ 시간이라고 볼 수 있다.

두 가지로 구현될 수 있는 다익스트라 알고리즘을 비교해보면,  
최악의 경우를 가정했을 때,

그래프 내의 간선의 수가 작을 때($m < n^2 / \log n$)는 힙 구현을 통해 수행하는 것이 낫고,  
그래프 내의 간선의 수가 많을 때($m > n^2 / \log n$)는 배열 구현을 통해 수행하는 것이 낫다.

만약 피보나치 힙을 통해 다익스트라 알고리즘을 구현하는 경우,  
$O(m + n\log n)$의 수행시간으로 작동하게 할 수 있다.
