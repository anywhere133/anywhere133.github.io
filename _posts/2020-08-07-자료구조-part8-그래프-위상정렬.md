---
title: "자료구조 with Python : Part 8-3 위상 정렬"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 그래프
  - 위상 정렬
  - Topological Ordering
  - 유향 비순환 그래프
  - Directed Acyclic Graph
  - data structure
use_math: true
---

### 그래프

#### 위상 정렬<sup>Topological Ordering</sup>

특정 업무를 수행하는 데 있어서 세부적으로 여러 행동들로 나눌 수 있다.  
이 업무가 마무리되려면 세부적으로 나누어진 행동들을 순서대로 해야한다.  
따라서 세부적으로 나누어진 행동들에는 상호 선후관계가 존재한다.  

이러한 세부 행동들이 그래프의 정점으로 표현될 수 있고,  
그 선후 관계가 정점들 간의 간선으로 표현될 수 있다.  
여기서 행동들의 관계가 선후가 존재하므로 간선에 방향이 존재한다.  

이러한 것을 그래프로 표현하게 되면,  
유향 비순환 그래프<sup>Directed Acyclic Graph</sup>이라고 한다.  

위의 유향 그래프를 $n$개의 정점을 가진 $\overrightarrow G$라고 하면,  
$\overrightarrow G$의 위상정렬은 정점을 $v_1, v_2, \cdots, v_n$와 같이 정렬하는 것이다.  
정확하게는 $\overrightarrow G$의 어떤 간선 $(v_i, v_j)$가 있을 때,  
$i < j$이어야 한다.

따라서 위상 정렬은 $\overrightarrow G$의 정점을 거치는 어떤 유향 경로를  
오름차순으로 정렬한다.

위의 조건들을 정리하면  
* $\overrightarrow G$는 사이클이 없는 유향 그래프이다.  
* $\overrightarrow G$의 간선 $(v_i, v_j)$에서 $i < j$이어야 한다.

여기서 $\overrightarrow G$는 유향 그래프이므로 간선을 두 가지로 나누어 볼 수 있다.  
한 정점을 기준으로 정점으로 들어오는 간선을 진입 간선<sup>Incoming Edge</sup>이라 하고,  
반대로 정점에서 나가는 간선을 진출 간선<sup>Outgoing Edge</sup>이라고 한다.

위상 정렬이 만들어 지는 과정을 설명하면,  
$\overrightarrow G$에서 진입 간선이 없는 정점이 적어도 하나 이상이 존재한다.  
이 정점을 $v_1$이라고 하자.  
만약 그러한 정점 $v_1$이 없다고 하면, 경로를 따라 탐색하다보면 전에 방문한 정점을 다시 방문하게 된다.  
이는 싸이클이 없다는 기본 조건에 위배된다.  

만약 $\overrightarrow G$에서 $v_1$과 그 정점의 진출 간선을 제거하면,  
그래도 $\overrightarrow G$에는 싸이클이 존재하지 않는다.  
따라서 동시에 진입 간선이 없는 정점이 무조건 존재한다.  
이 정점을 $v_2$라고 하자.

이러한 과정을 유향 그래프가 비어질 때까지 반복하다보면,  
$\overrightarrow G$의 정점들이 $v_1, \cdots, v_n$ 순으로 정렬된 것을 얻을 수 있다.  
위의 과정에서 삭제 과정을 이어가다 보면 $\overrightarrow G$의 간선 $(v_i, v_j)$에서  
언제나 $v_i$가 $v_j$보다 앞서 삭제된다. 따라서 $i < j$의 조건이 성립되게 된다.  

위상 정렬은 말 그대로 Topological Sort이라고도 한다.

다음은 위상정렬을 파이썬 코드로 구현한 것이다.
```python
def topological_sort(g):
    topo = []                   # 위상 정렬된 정점들이 저장됨
    ready = []                  # 진입 간선이 0인 정점들이 저장됨
    incount = {}                # 각각의 정점과 그 정점의 진입 간선의 수를 dict로 저장

    for u in g.vertices():      # 모든 정점들에 대해서
        incount[u] = g.degree(u, False) # 해당 간선의 진입 간선 수를 키 u에 값으로 저장
        if incount[u] == 0:     # 만약 해당 정점의 진입 간선 수가 0이면
            ready.append(u)     # ready 리스트에 저장

    while len(ready) > 0:
        u = ready.pop()         # 진입 간선이 0인 정점 추출
        topo.append(u)          # 위상 정렬 리스트에 추출한 정점 저장
        for e in g.incident_edges(u):   # 추출한 정점의 진출 간선들에 대해
            v = e.opposite(u)   # 진출 간선에서 반대쪽 정점 지정
            incount[v] -= 1     # 진출 간선들의 삭제로 인해 v의 진입간선 수 감소
            if incount[v] == 0: # 만약 해당 정점의 진입 간선 수가 0이면
                ready.append(v) # ready 리스트에 추가
    return topo                 # 위상 정렬된 정점 리스트 반환
```

위에 구현된 코드를 확인해보면,  
부가적으로 그래프 $G$가 사이클의 존재 여부를 확인할 수 있다.  
만약 알고리즘이 모든 정점들에 대해 위상정렬하지 못하고 종료되면,  
해당 그래프 내의 하위 그래프에 정렬되지 못하는 사이클인 정점들이 존재한다는 것이다.


##### 위상 정렬의 수행시간 분석

$\overrightarrow G$가 유향 그래프라고 할 때,   
$n$은 그 그래프의 정점, $m$은 그 그래프의 간선이다.  
또 해당 그래프는 인접 리스트로 구현한다.  
(인접 행렬 : $O(n^2)$ 시간 | 인접 리스트 : $O(n + m)$ 시간)

따라서 인접 리스트를 사용하기 때문에,  
$O(n+m)$ 시간과 $O(n)$만큼의 공간을 사용한다.  
이는 위상정렬이 완료되거나 사이클이 존재하여 위상 정렬에 실패하는 경우 둘다 동일하다.

세부적으로 수행시간의 분석을 해보면,  
모든 간선 $n$에 대해서 진입 간선의 수를 파악해야 하므로  
`degree()`를 포함하는 for문 이하 구문에서는 $O(n)$ 시간이 소요된다.

다음으로 진입 간선이 없는 정점을 중심으로 진출하는 간선들 만큼  
while 문 내에 for 문이 진행되므로, 해당 for 문은 진출 간선의 수만큼 소요된다.  
모든 진출 간선의 수는 적어도 $m$보다 같거나 작기 때문에 $O(m)$ 시간이라 볼 수 있고,  
while 문은 사이클 없다면 모든 정점들이 진입 간선의 수가 0이 되어  
topo 리스트에 추가되기 때문에 $O(n)$ 시간이 소요된다.

두 과정은 동일한 수행에서 처리되므로 $O(n + m)$ 시간이 소요된다고 볼 수 있다.  

따라서 위상정렬의 수행시간은 $O(n + m)$ 시간만큼 소요되고,  
적어도 정점 $n$개 만큼이 topo, ready, incount에 저장되고 삭제되므로  
$O(n)$ 만큼의 공간 복잡도를 가지게 된다.




