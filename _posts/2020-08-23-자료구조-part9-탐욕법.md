---
title: "자료구조 with Python : Part 9 탐욕 알고리즘"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 탐욕 알고리즘
  - 탐욕법
  - Greedy Algorithm
  - data structure
use_math: true
---

### 탐욕 알고리즘<sup>Greedy Algorithm</sup>

눈 앞의 이익만을 우선 추구하는 알고리즘을 총칭해서  
탐욕 알고리즘 혹은 그리디 알고리즘이라 한다.  

탐욕 알고리즘은 대부분의 경우 뛰어난 결과를 도출하지 못하지만  
드물게 최적해를 보장하는 경우도 존재한다.  
이처럼 최적화 문제를 대상으로 한다.

최적해를 찾을 수 있으면 그것을 목표로 삼고,  
찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 한다.

다음은 전형적인 탐욕 알고리즘의 구조, 슈도 코드다.

```
do {
    조건 중 가장 좋아 보이는 선택을 한다;
} until (해 구성 완료)
```

탐욕 알고리즘은 하나의 온전한 해가 만들어질 때 까지 눈 앞에 가장 좋아보이는 선택을 반복한다.

예를 들어, 앞서 크루스칼 알고리즘이 대표적인 예이다.  
$n$개의 정점을 가진 어떤 그래프의 최소 신장 트리는 사이클을 이루지 않은 총 $n-1$개의 간선으로 이루어진다.

크루스칼 알고리즘은 위의 최소신장트리를 만들기 위해 간선을 하나씩 더해가 $n-1$개의 간선까지 더해나간다.

이 과정의 각 단계에서 어떤 간선을 택할지 결정하는 로직이 있어야 한다.  
이 로직이 눈앞의 이익만 추구하면 탐욕 알고리즘 계열에 속하게 된다.

최소신장트리 문제에서는 간선을 하나 더할 때마다 해당 간선이  
기존에 선택된 간선들과 사이클을 이루지는 않는지 확인해야 한다.

모든 탐욕 알고리즘은 이런 구성요소들을 포함한다.  
즉 각 단계에서 선택되는 원소의 기준이 눈 앞의 이익을 우선해야 하고 그것이 최적해를 보장한다는 것이며,  
선택되는 원소가 더해지므로써 온전한 해가 될 가능성이 없어지지 않았는지 확인하여야 한다.

위와 같은 두 조건을 탐욕스러운 선택 조건<sup>Greedy Choice Property</sup>와  
최적 부분 구조 조건<sup>Optimal Substructure</sup>이라 한다.

탐욕스러운 선택 조건<sup>Greedy Choice Property</sup>  
: 앞의 선택이 이후의 선택에 영향을 주지 않는 조건

최적 부분 구조 조건<sup>Optimal Substructure</sup>  
: 문제에 대한 최종 해결 방법이 부분 문제에 대해서도 또한 최적 문제 해결방법이라는 조건

다음 글에서는 탐욕 알고리즘을 통해 최적해를 보장하지 못하는 경우를 알아보고,  
그 다음에 최적해를 보장받는 경우를 알아보자.