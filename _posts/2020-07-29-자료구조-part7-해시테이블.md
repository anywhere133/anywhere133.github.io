---
title: "자료구조 with Python : Part 7 해시 테이블"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 헤시 테이블
  - 체이닝
  - data structure
use_math: true
---

### 해시 테이블


#### 해시 테이블<sup>Hash Table</sup>

이진탐색트리가 점차 발전하면서  
수행 성능이 $O(\log N)$까지 내려왔다.  
그런데 이 보다 더 좋은 성능을 갖는 자료구조는 없을까? 

해시 테이블은 $O(\log N)$ 시간보다 빠른 연산을 위해,  
키와 1차원 리스트의 인덱스의 관계를 이용하여 키를 저장한다.

그러나 키를 1차원 리스트의 인덱스를 그대로 사용하면 메모리 낭비가 심해질 수 있다.  
이러한 문제를 해결하려면 키를 적절히 변환하여  
리스트의 인덱스로 사용해야 한다.

이 때 키를 간단한 함수를 사용해 변환한 값을 리스트의 인덱스로 이용하여  
항목을 저장하는 것을 **해싱**<sup>hashing</sup>이라고 한다.  
해싱에 사용되는 함수를 **해시 함수**<sup>hash function</sup>라 하고,  
해시함수가 계산한 값을 **해시값**<sup>hash value</sup> 또는 **해시 주소**라고 하며,  
항목이 해시값에 따라 저장되는 1차원 리스트를 **해시 테이블**이라고 한다.

해시 테이블에 원소가 차 있는 비율은 해시 테이블의 성능에 매우 중요한 영향을 미친다.  
이 비울을 적재율<sup>Load Factor</sup>이라 한다.   
해시 테이블의 크기가 $m$이고, 저장된 원소의 총수가 $n$이면,  
적재율은 $n \over m$이고 보통 $\alpha$로 표기한다.

우수한 해시함수를 사용해도,  
2개 이상의 항목을 해시 테이블의 동일한 원소에 저장하여야 하는 경우가 발생한다.  
이와 같이 서로 다른 키들이 동일한 해시값을 가질 때 **충돌**<sup>collision</sup>이 발생했다고 한다.

충돌 해결 방법들은 크게 두 가지로 분류되는데,  
개방주소방식<sup>Open Addressing</sup>, 폐쇄주소방식<sup>Closed Addressing</sup>으로 나눌 수 있다.

**개방주소방식**은 충돌된 키들을 해시테이블 전체를 열린 공간으로 여겨  
비어 있는 곳을 찾아 항목을 찾아 저장하는 방식이다.  
즉 충돌이 발생한 키를 원래의 해시 값과 다른 곳에 저장한다는 의미이다.

**폐쇄주소방식**은 해시 값에 대응되는 해시 테이블 원소에 반드시 키를 저장한다.  
따라서 충돌이 발생한 키들을 동일한 해시주소에 저장한다.


##### 해시함수
해시 함수는 키 값을 입력으로 받아, 해시 테이블 상의 주소를 리턴한다.  
해시 함수는 다음 두 가지 성질을 가지도록 만들어야 한다.

* 입력 원소가 해시 테이블 전체에 고루 저장되어야 한다.
* 계산이 간단해야 한다.

첫 번째 성질이 가장 중요한데, 이 성질을 잘 만족해야  
서로 다른 두 원소가 한 주소를 놓고 충돌할 확률이 작아지기 때문이다.  
두 번째 성질은 첫 번째 성질을 만족하기 위해서는 복잡한 계산이 필요하지 않기 때문에  
보통 쉽게 만족한다.


주민등록번호는 생년월일, 성별, 지역코드, 검증번호로 이루어져 있다.  
해시 값의 대표적인 예시이다.  
이런 키의 가장 앞 부분의 몇 자리, 또는 뒤의 몇 자리 등을 취하여  
해시값으로 사용하는 단순한 방식의 해시함수는 많은 충돌을 야기할 수 있다.

해시함수는 키들을 균등하게 해시 테이블의 인덱스로 변환하기 위해 의미가 부여되어 있는 키를  
간단한 계산을 통해 뒤죽박죽 만든 후 해시테이블의 크기에 맞도록 해시값을 계산한다.

하지만 아무리 균등한 결과를 보장하는 해시함수일지라도 함수 계산 자체에  
긴 시간이 소요된다면 해싱의 장점인 연산의 신속성을 상실하므로 가치를 잃는다.

따라서 단순하면서 동시에 키들을 균등하게 변환하는 함수가 해시함수로서 바람직하다.  
이러한 해시함수의 대표적인 예는 다음과 같다.

* 중간제곱<sup>Mid-square</sup> : 키를 제곱한 후, 적절한 크키의 중간부분을 해시값으로 사용한다.

* 접기<sup>Folding</sup> : 큰 자릿수를 갖는 십진수를 키로 사용하는 경우, 몇 자리씩 일정하게 끊어서  
                        만든 숫자들의 합을 이용해 해시값을 만든다.  
                        예를 들어 123456789012에 대해 1234+5678+9012 = 15924를 계산한 후에  
                        해시 테이블의 크기가 1000이라면 15924에서 3자리 수만을 해시값으로 사용한다.

* 곱셈<sup>Multiplicative</sup> : 1보다 작은 실수 $\delta$를 키에 곱하여 얻은 숫자의 소수 부분을  
                                테이블 크기 $M$과 곱한다. 이렇게 나온 값의 정수 부분을 해시값으로  
                                사용한다. 즉, $h(key) = ((key * \delta) % 1) * M$이다.  
                                Knuth에 의하면 $\delta = {{\sqrt 5} - 1}\over 2} \approx 0.61803$이 
                                좋은 성능을 보인다.  
                                예를 들면 테이블 크기 $M = 127$이고 키가 123456789인 경우,  
                                123456789 $\times$ 0.61803 = 76299999.**30567**,  
                                0.30567 $\times$ 127 = **38**.82009이므로 38을 해시값으로 사용한다.

이러한 해시함수들의 공통점은 키의 모든 자리의 숫자들이 함수 계산에 참여함으로써 계산 결과에서는  
원래의 키에 부여된 의미나 특성을 찾아볼 수 없게 된다는 점을 들 수 있다.  
또한 계산 결과에서 해시 테이블의 크기에 따라 특정 부분만을 해시값으로 활용한다는 점도 공통점에 해당한다.

하지만 실세계에서 가장 널리 사용되는 해시함수는 나눗셈<sup>Division</sup>이다.  
나눗셈 함수는 키를 소수 M으로 나눈 뒤, 그 나머지를 해시값으로 사용한다.  
즉, $h(key) = key % M$이고, 따라서 해시 테이블의 인덱스는 0에서 $M-1$이 된다.  
여기서 M을 소수를 사용하는 이유는 나눗셈 연산을 했을 때, 소수가 키들을 균등하게  
인덱스로 변환시키는 성질을 갖기 때문이다.  
또한 M은 2의 제곱수에 가깝지 않은 소수를 선택하는 것이 좋다.

만일 $m=2^p$라면, 입력 원소의 하위 $p$ 비트에 의해 해시 값이 결정되므로  
해시 값을 분산시키기에 그리 이상적이지 않다.  
서로 다른 두 원소가 비슷하다 해서, 그 둘이 인접한 자리에 위치하는 경향이 있다면  
좋은 해시 함수가 아니다. 해시 값은 입력 원소의 모든 비트를 이용하는 것이  
확률적으로 좋은 분포를 갖도록 하는데 유리하다. 
 
 