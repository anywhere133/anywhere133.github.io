---
title: "자료구조 with Python : Part 6-5 레드블랙트리(추가)"
layout: single
comments: true
categories:
  - Data Structure
tags:
  - 자료 구조
  - 레드블랙트리
  - data structure
use_math: true
---

### 탐색 트리


#### 레드블랙트리<sup>Red-Black Tree</sup>

##### 레드블랙트리의 특성
1. 루트는 블랙이다
2. 모든 리프(NIL)은 블랙이다.
3. 노드가 레드이면 그 노드의 자식은 반드시 블랙이다.
4. 루트 노드에서 임의의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다.

여기서 말하는 리프 노드, 이파리 노드는 일반적인 리프 노드와는 다르다.  
이진탐색트리에서의 리프 노드는 다음 자식 노드가 없는, 즉 None인 노드를 가진 노드를 말한다.  
그러나 레드블랙트리에서의 리프 노드는 데이터 값을 가지고 있지 않지만, 색상 값을 가지는 노드이다.  
즉 NIL 노드가 트리의 끝에 존재하는 리프 노드로 존재하게 된다.

그런데, 트리의 높이($h$)가 커질 수록 리프 노드의 개수가 $2^h$만큼 늘어난다.  
따라서 모든 리프 노드가 None 값을 갖는 블랙 노드(NIL)라면,  
노드의 자식이 없는 쪽을 하나의 NIL 노드 만을 레퍼런스하도록 하면  
여러모로 편리하게 다룰 수 있다.


레드블랙트리에서 검색은 트리의 내용을 건드리지 않으므로  
이진탐색트리에서 검색가 동일하다. (중위순회)

삽입과 삭제도 기본적으로 이진탐색트리와 동일하지만,  
삽입이나 삭제 후 레드블랙 특성을 위반하는 경우가 발생할 수 있다.  
이때는 적절한 작업을 해서 레드 블랙 특성을 만족하도록 바로 잡아야 함.

##### 레드블랙트리의 삽입
레드블랙트리에서 노드를 삽입할 때는 먼저 이진탐색트리의 삽입 알고리즘에 따라 삽입한 다음  
새 노드의 색상을 레드로 칠한다. 이 노드를 $x$라 하자.

새 노드는 항상 맨 아래쪽에 매달리므로, 삽입 직후에 $x$의 아래쪽은  
블랙 노드인 리프 2개만 있어 레드블랙 특성에서 문제가 생기지 않는다.  
$x$의 위쪽과 관련해서 문제가 생기는지만 확인하면 된다.
 
$x$의 부모 노드 $p$가 블랙이면 그것으로 삽입은 완료된다.  
그러므로 $p$가 레드인 경우만 해결하면 된다.

$p$가 레드이면 레드 노드가 2개 연속으로 있으므로 레드블랙 특성 3을 위반한다.  
그런데 삽입 전에는 레드블랙트리였으므로 특성 3에 따라 $p$의 부모노드는 반드시 블랙이다.  
이를 $p^2$라 하자. 마찬가지로 특성 3에 따라 $x$의 형제 노드도 반드시 블랙이다.  
$x$ 주변에서 레드나 블랙 두 가지가 다 가능한 것은 $p$의 형제 노드 $s$뿐이다.  
$s$의 색상에 따라 다음 두 가지 경우로 나눌 수 있다.

그 전에 정리하자면,  
삽입된 노드 : $x$  
$x$의 부모 노드 : $p$  
$p$의 부모 노드 : $p^2$  
$p$의 형제 노드($x$의 삼촌 노드) : $s$  
이다.

다음은 두 가지 경우이다.
* Case 1 : $s$가 레드
* Case 2 : $s$가 블랙
    * Case 2-1 : $x$가 $p$의 오른쪽 자식
    * Case 2-2 : $x$가 $p$의 왼쪽 자식

단, $p$가 $p^2$의 왼쪽 자식인지 오른쪽 자식인지에 따라 두 가지 경우로 나누어지는데,  
이 두 경우는 서로 정확히 대칭이므로 여기서는 $p$가 $p^2$의 왼쪽 자식인 경우에만 설명

###### Case 1
$p$와 $s$의 색상을 레드에서 블랙으로 바꾸고, $p^2$의 색상을 블랙에서 레드로 바꾼다.  
$p^2$가 루트이면, $p^2$의 색상을 다시 블랙으로 바꾸고 끝난다.

$p^2$가 루트가 아니면, $p^2$의 부모 색상을 확인해야 한다.  
$p^2$의 부모 색상이 블랙이면 레드블랙 특성이 모두 만족된다.

$p^2$의 부모 색상이 레드이면 레드블랙 특성 3이 위반되어 처음과 동일한 문제가 발생한다.  
원래 $x$에 대해 발생했던 문제와 동일한 문제가 $p^2$에 발생했음을 뜻한다.  
$p^2$를 삽입 노드처럼 생각하여, 재귀적으로 다시 시작한다.

###### Case 2

* Case 2-1
$p$를 중심으로 왼쪽으로 회전한다.  
여전히 레드블랙 특성 3을 위반한다.  
Case 2-2로 이동한다.

* Case 2-2
$p^2$를 중심으로 오른쪽으로 회전한다.  
$p$와 $p^2$의 색상을 맞바꾼다.


Case 2를 만나면, Case 2-2의 수선을 마지막으로 상황이 종료된다.  
Case 1을 만나면 상황이 끝날 수도 있고 똑같은 상황이 다른 노드에서 다시 시작될 수 있다.  
이런 상황이 재귀적으로 반복되어 루트까지 올라갈 수 있다.


##### 레드블랙트리에서의 삭제

레드블랙트리에서 노드를 삭제할 때는  
기본적으로 이진검색트리에서 삭제방법에 따라 노드를 삭제한 후 색상을 맞추어준다.  
이진검색트리에서 임의의 노드 $d$를 삭제할 때 $d$의 자식이 둘이면  
$d$의 오른쪽 서브트리에서 최소 원소(중위 순회에서 노드 $d$의 직후 원소)를 가진  
(또는 $d$의 왼쪽 서브트리에서 최대 원소, 중위 순회에서 노드 $d$의 직전 원소,를 가진)  
노드 $m$의 키를 노드 $d$로 옮긴 다음 노드 $m$을 삭제한다.  

노드 $d$의 색상을 건드리지 않은 채 키만 바뀌는 것은 레드블랙 특성에 영향을 미치지 않는다.  
문제가 되는 것은 최소 원소 노드 $m$을 삭제한 후 $m$ 주변의 레드블랙 특성의 위반여부이다.

최소 원소 노드 $m$은 왼쪽 자식을 갖지 않는다.(중위 순회에서의 최소값이기 때문)  
따라서 최소 원소 노드 $m$을 최대 한 개의 자식만을 가질 수 있으므로  
두 개의 자식을 가진 노드의 삭제 작업은 자식이 없거나 한 개만을 가진 노드의 삭제 작업으로 귀결된다.  

따라서 레드블랙트리에서 삭제 작업은 자식이 없거나 한 개만을 가진 노드의 삭제에 국한해 설명해도 무방.

삭제하려고 하는 노드 $m$의 (최대 한 개의) 자식을 $x$라고 하자.  
자식이 없으면 $x$는 NIL 노드가 된다.  
$m$은 자기 부모노드의 왼쪽 자식일 수 있고, 오른쪽 자식일 수 있다.  
두 경우는 완전히 대칭적이므로 둘 중 하나만 설명한다.  
여기서는 $m$이 자기 부모의 왼쪽 자식이라 가정한다.  

간단한 경우는 다음과 같다.  
$m$이 레드이면 삭제 후 아무런 조치가 필요없다.  
레드블랙 특성이 깨지지 않기 때문이다. 따라서 $m$이 블랙인 경우만 고려하면 된다.  

$m$이 불랙이더라도 $x$가 레드이면 삭제 후 $x$의 색상을 블랙으로 바꾸어버리면,  
레드블랙 특성을 만족한다.

정리하자면 다음과 같은 경우에는 $m$이 삭제되더라도 문제가 없다.  
순서는 다음과 같다. <$m$, $x$>  
* <레드, 블랙> / (<레드, 레드>는 특성 위반이기 때문에 이전에 존재할 수 없음.)
* <블랙, 레드>

위의 경우에는 $m$이 삭제되어도, black height가 변하지 않기 때문에 문제가 없다.

복잡한 경우는 <블랙, 블랙>인 경우인데  
$m$의 서브트리 부분의 black height가 다른 곳보다 1만큼 낮게 된다.

다시 말하면 $m$을 삭제하고 $x$로 대체하게 되면,  
루트부터 $x$를 지나는 경로에서의 블랙노드의 수가 하나 모자람을 의미한다.  
이 경우에는 $x$의 부모노드와 형제노드, 형제노드의 자식노드들의 상태에 따라 처리방법이 다르다.

여기서 $x$의 부모노드를 $p$, 형제노드를 $s$, 형제노드의 두 자식노드를 각각 $l$과 $r$이라 하자.  
이들 $p, s, l, r$의 색상 분포에 따라 여러 가지 경우로 나누어 처리한다.  

먼제 $p$의 색상에 따라 Case 1(레드)와 Case 2(블랙)로 나눈다.  
$p$가 레드이면 $s$는 반드시 블랙이다.  
$l, r$은 모든 색상 조합이 가능하다. <$l$, $r$>의 색상 조합에 따라 총 네 가지로 나눌 수 있다.  
이 중 두 가지는 알고리즘에서 통합해 처리하므로 세 가지로 나눈다.  
여기서 *는 어떤 색상이든 상관없음을 뜻한다.

* Case 1 : $p$가 레드($s$는 반드시 블랙). <$l$의 색상, $r$의 색상>에 따라
  * Case 1-1 <블랙, 블랙>
  * Case 1-2 < * , 레드>
  * Case 1-3 <레드, 블랙>


$p$가 블랙이면 $s$는 블랙, 레드가 모두 가능하다.  
<$s$의 색상, $l$의 색상, $r$의 색상>에 따라 다음과 같이 네 가지로 나눈다.

* Case 2 : $p$가 블랙. <$s$의 색상, $l$의 색상, $r$의 색상>에 따라
  * Case 2-1 <블랙, 블랙, 블랙>
  * Case 2-2 <블랙,  * , 레드>
  * Case 2-3 <블랙, 레드, 블랙>
  * Case 2-4 <레드, 블랙, 블랙>

여기서 Case 1-2와 Case 2-2는 $p$의 색상만 다르다.  
이 두 경우는 $p$의 색상이 처리방법에 영향을 미치지 않으므로 통합한다.

그 다음 Case 1-3와 Case 2-3도 마찬가지 이유로 통합한다.

최종적으로 알고리즘이 처리하는 경우의 수는 총 다섯 가지이다.  
각각 Case 1-1, Case *-2, Case *-3, Case 2-1, Case 2-4라고 하자.  
이 다섯 가지의 경우들 모두 특성 4를 위반한다.

이제는 각 경우에 대한 처리방법에 대해 소개한다.

* Case 1-1
단순히 $p$와 $s$의 색상을 맞바꾼다.  
$x$에 이르는 경로상에서 블랙이 하나 추가되었으므로  
$x$에 이르는 경로에서 블랙노드가 하나 모자랐던 것이 해소되었다.  
루트에서 $s$를 지나는 경로 상의 블랙노드 수에는 변화가 없다. 특성 4가 만족되었다.

* Case *-2
$p$를 중심으로 왼쪽으로 회전시키고, $p$와 $s$의 색상을 바꾼 다음  
$r$의 색상을 레드에서 블랙으로 바꾼다.

$x$에 이르는 경로상에서 블랙이 하나 추가되었으므로  
$x$를 지나는 경로에서 블랙노드가 하나 모자라던 것이 해소되었다.  
특성 4가 만족된다.

* Case *-3
$s$를 중심으로 오른쪽 회전시키고 $l$과 $s$의 색상을 맞바꾼다.  
Case *-2로 이동한다.

* Case 2-1
단순히 $s$의 색상을 블랙에서 레드로 바꾼다.  
이제 $s$를 지나가는 경로에서도 블랙노드가 하나 모자라게 되어  
$p$를 지나가는 경로 전체에서 블랙노드 하나가 모자라게 된다.

그렇게 되면 원래 $x$에서 발생했던 문제가 $p$에서 발생한 문제로 보고  
$p$를 기준으로 재귀적으로 다시 시작한다.

* Case 2-4
$p$를 중심으로 왼쪽으로 회전시키고 $p$와 $s$의 색상을 맞바꾼다.  
$l$과 $r$을 경유하는 경로와 관련해서는 문제가 없다.  
다만 문제가 발생한 $x$의 부모노드의 색상이 블랙에서 레드로 바뀌었다.  
이는 Case 1에 해당된다. 색상의 조합을 따져 Case 1-1, 1-2, 1-3 중 하나로 이동.
